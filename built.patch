diff --git a/cmake/dependencies/common.cmake b/cmake/dependencies/common.cmake
index 5ca477b..94fc40f 100644
--- a/cmake/dependencies/common.cmake
+++ b/cmake/dependencies/common.cmake
@@ -1,6 +1,7 @@
 include(FetchContent)
 
 find_package(OpenGL QUIET)
+find_package(Vulkan QUIET)
 
 #=================== ImGui ===================
 set(imgui_fixes_and_config_patch_file ${CMAKE_CURRENT_SOURCE_DIR}/cmake/dependencies/patches/imgui-fixes-and-config.patch)
@@ -33,6 +34,14 @@ target_sources(ImGui
     ${imgui_SOURCE_DIR}/backends/imgui_impl_sdl2.cpp
 )
 
+if(Vulkan_FOUND)
+    message("Vulkan found")
+    target_sources(ImGui
+            PRIVATE
+            ${imgui_SOURCE_DIR}/backends/imgui_impl_vulkan.cpp
+    )
+endif()
+
 target_include_directories(ImGui PUBLIC ${imgui_SOURCE_DIR} ${imgui_SOURCE_DIR}/backends PRIVATE ${SDL2_INCLUDE_DIRS})
 
 # ========= StormLib =============
@@ -102,7 +111,6 @@ FetchContent_Declare(
 FetchContent_MakeAvailable(ThreadPool)
 
 list(APPEND ADDITIONAL_LIB_INCLUDES ${threadpool_SOURCE_DIR}/include)
-
 #=========== prism ===========
 option(PRISM_STANDALONE "Build prism as a standalone library" OFF)
 FetchContent_Declare(
@@ -110,4 +118,52 @@ FetchContent_Declare(
     GIT_REPOSITORY https://github.com/KiritoDv/prism-processor.git
     GIT_TAG 493974843e910d0fac4e3bb1ec52656728b875b4
 )
-FetchContent_MakeAvailable(prism)
\ No newline at end of file
+FetchContent_MakeAvailable(prism)
+
+set(LLGL_BUILD_EXAMPLES OFF)
+set(LLGL_BUILD_RENDERER_NULL OFF)
+set(LLGL_GL_ENABLE_DSA_EXT ON)
+set(LLGL_GL_ENABLE_VENDOR_EXT ON)
+set(LLGL_GL_INCLUDE_EXTERNAL ON)
+if (Vulkan_FOUND)
+    set(LLGL_BUILD_RENDERER_VULKAN ON)
+else()
+    set(LLGL_BUILD_RENDERER_VULKAN OFF)
+endif()
+
+set(llgl_patch_file ${CMAKE_CURRENT_SOURCE_DIR}/cmake/dependencies/patches/llgl.patch)
+
+# Applies the patch or checks if it has already been applied successfully previously. Will error otherwise.
+set(llgl_apply_patch_if_needed git apply ${llgl_patch_file} ${git_hide_output} || git apply --reverse --check ${llgl_patch_file})
+
+FetchContent_Declare(
+        llgl
+        GIT_REPOSITORY https://github.com/LukasBanana/LLGL.git
+        GIT_TAG 310e6b9f6c173ac2dac11b765e0fd0a7f66f1286
+        PATCH_COMMAND ${llgl_apply_patch_if_needed}
+)
+FetchContent_MakeAvailable(llgl)
+list(APPEND ADDITIONAL_LIB_INCLUDES ${llgl_SOURCE_DIR}/include)
+link_libraries(LLGL)
+
+
+include(cmake/FindVulkan.cmake)
+set(SPIRV-Cross_DIR cmake/FIndPkgs)
+find_package(Vulkan REQUIRED SPIRV-Tools)
+find_package(Vulkan REQUIRED glslang)
+
+link_libraries(Vulkan::SPIRV-Tools)
+link_libraries(Vulkan::glslang)
+
+find_package(SPIRV-Cross REQUIRED)
+link_libraries(
+        SPIRV-Cross::spirv-cross-core
+        SPIRV-Cross::spirv-cross-glsl # or others as needed
+        SPIRV-Cross::spirv-cross-msl # or others as needed
+        SPIRV-Cross::spirv-cross-hlsl
+)
+
+if(WIN32)
+    set(EXTERNAL_INCLUDE_DIR "${llgl_SOURCE_DIR}/external")
+    include_directories("${EXTERNAL_INCLUDE_DIR}/OpenGL/include")
+endif()
\ No newline at end of file
diff --git a/cmake/dependencies/windows-vcpkg.cmake b/cmake/dependencies/windows-vcpkg.cmake
index d8329fe..b53d01e 100644
--- a/cmake/dependencies/windows-vcpkg.cmake
+++ b/cmake/dependencies/windows-vcpkg.cmake
@@ -10,5 +10,5 @@ if (USE_AUTO_VCPKG)
 	endif()
 
 	vcpkg_bootstrap()
-	vcpkg_install_packages(zlib bzip2 sdl2 glew libzip nlohmann-json tinyxml2 spdlog)    
+	vcpkg_install_packages(zlib bzip2 sdl2 glew libzip nlohmann-json tinyxml2 spdlog glslang spirv-cross)
 endif()
diff --git a/cmake/dependencies/windows.cmake b/cmake/dependencies/windows.cmake
index 6b3b7b2..3d7ccaa 100644
--- a/cmake/dependencies/windows.cmake
+++ b/cmake/dependencies/windows.cmake
@@ -2,6 +2,7 @@
 target_sources(ImGui
 	PRIVATE
 	${imgui_SOURCE_DIR}/backends/imgui_impl_dx11.cpp
+	${imgui_SOURCE_DIR}/backends/imgui_impl_dx12.cpp
 	${imgui_SOURCE_DIR}/backends/imgui_impl_win32.cpp
 )
 
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 0df27f7..a92d1af 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -87,6 +87,11 @@ target_sources(libultraship PRIVATE ${Source_Files__Window})
 
 file(GLOB_RECURSE Source_Files__Window__Gui RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "window/gui/*.h" "window/gui/*.cpp")
 
+if(APPLE)
+    file(GLOB Source_Files__Window__Gui__Apple RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "window/gui/*.mm")
+    list(APPEND Source_Files__Window__Gui ${Source_Files__Window__Gui__Apple})
+endif()
+
 source_group("window/gui" FILES ${Source_Files__Window__Gui})
 target_sources(libultraship PRIVATE ${Source_Files__Window__Gui})
 
diff --git a/src/config/Config.cpp b/src/config/Config.cpp
index 69be631..38ed9cc 100644
--- a/src/config/Config.cpp
+++ b/src/config/Config.cpp
@@ -318,6 +318,9 @@ void Config::SetWindowBackend(WindowBackend backend) {
         case WindowBackend::FAST3D_SDL_METAL:
             SetString("Window.Backend.Name", "Metal");
             break;
+        case WindowBackend::FAST3D_SDL_LLGL:
+            SetString("Window.Backend.Name", "LLGL");
+            break;
         default:
             SetString("Window.Backend.Name", "");
     }
diff --git a/src/graphic/Fast3D/Fast3dWindow.cpp b/src/graphic/Fast3D/Fast3dWindow.cpp
index ca3abf0..203bfd5 100644
--- a/src/graphic/Fast3D/Fast3dWindow.cpp
+++ b/src/graphic/Fast3D/Fast3dWindow.cpp
@@ -12,6 +12,7 @@
 #include "graphic/Fast3D/backends/gfx_direct3d_common.h"
 #include "graphic/Fast3D/backends/gfx_direct3d11.h"
 #include "backends/gfx_window_manager_api.h"
+#include "graphic/Fast3D/backends/gfx_llgl.h"
 
 #include <fstream>
 
@@ -33,6 +34,7 @@ Fast3dWindow::Fast3dWindow(std::shared_ptr<Ship::Gui> gui) : Ship::Window(gui) {
         AddAvailableWindowBackend(Ship::WindowBackend::FAST3D_SDL_METAL);
     }
 #endif
+    AddAvailableWindowBackend(Ship::WindowBackend::FAST3D_SDL_LLGL);
     AddAvailableWindowBackend(Ship::WindowBackend::FAST3D_SDL_OPENGL);
 }
 
@@ -137,6 +139,10 @@ void Fast3dWindow::InitWindowManager() {
             mWindowManagerApi = new GfxWindowBackendSDL2();
             break;
 #endif
+        case Ship::WindowBackend::FAST3D_SDL_LLGL:
+            mRenderingApi = new GfxRenderingAPILLGL();
+            mWindowManagerApi = new GfxWindowBackendSDL2();
+            break;
         default:
             SPDLOG_ERROR("Could not load the correct rendering backend");
             break;
@@ -180,10 +186,13 @@ bool Fast3dWindow::DrawAndRunGraphicsCommands(Gfx* commands, const std::unordere
     }
 
     auto gui = wnd->GetGui();
-    // Setup of the backend frames and draw initial Window and GUI menus
-    gui->StartDraw();
+
     // Setup game framebuffers to match available window space
     mInterpreter->StartFrame();
+
+    // Setup of the backend frames and draw initial Window and GUI menus
+    gui->StartDraw();
+
     // Execute the games gfx commands
     mInterpreter->Run(commands, mtxReplacements);
     // Renders the game frame buffer to the final window and finishes the GUI
diff --git a/src/graphic/Fast3D/backends/gfx_dxgi.cpp b/src/graphic/Fast3D/backends/gfx_dxgi.cpp
index f530b37..93d0c02 100644
--- a/src/graphic/Fast3D/backends/gfx_dxgi.cpp
+++ b/src/graphic/Fast3D/backends/gfx_dxgi.cpp
@@ -520,7 +520,7 @@ static uint64_t qpc_init, qpc_freq;
 GfxWindowBackendDXGI::~GfxWindowBackendDXGI() {
 }
 
-void GfxWindowBackendDXGI::Init(const char* game_name, const char* gfx_api_name, bool start_in_fullscreen,
+Ship::GuiWindowInitData GfxWindowBackendDXGI::Init(const char* game_name, const char* gfx_api_name, bool start_in_fullscreen,
                                 uint32_t width, uint32_t height, int32_t posX, int32_t posY) {
     LARGE_INTEGER lqpc_init, lqpc_freq;
     QueryPerformanceCounter(&lqpc_init);
@@ -603,6 +603,7 @@ void GfxWindowBackendDXGI::Init(const char* game_name, const char* gfx_api_name,
     mRawInputDevice[0].dwFlags = RIDEV_INPUTSINK;
     mRawInputDevice[0].hwndTarget = h_wnd;
     RegisterRawInputDevices(mRawInputDevice, 1, sizeof(mRawInputDevice[0]));
+    return {};
 }
 
 void GfxWindowBackendDXGI::SetFullscreenChangedCallback(void (*mOnFullscreenChanged)(bool is_now_fullscreen)) {
diff --git a/src/graphic/Fast3D/backends/gfx_metal.cpp b/src/graphic/Fast3D/backends/gfx_metal.cpp
index b965523..30ded68 100644
--- a/src/graphic/Fast3D/backends/gfx_metal.cpp
+++ b/src/graphic/Fast3D/backends/gfx_metal.cpp
@@ -132,7 +132,7 @@ int GfxRenderingAPIMetal::GetMaxTextureSize() {
     return mDevice->supportsFamily(MTL::GPUFamilyApple3) ? 16384 : 8192;
 }
 
-void GfxRenderingAPIMetal::Init() {
+void GfxRenderingAPIMetal::Init(Ship::GuiWindowInitData& data) {
     // Create the default framebuffer which represents the window
     FramebufferMetal& fb = mFramebuffers[CreateFramebuffer()];
     fb.mMsaaLevel = 1;
diff --git a/src/graphic/Fast3D/backends/gfx_metal.h b/src/graphic/Fast3D/backends/gfx_metal.h
index 6437893..a5fd95a 100644
--- a/src/graphic/Fast3D/backends/gfx_metal.h
+++ b/src/graphic/Fast3D/backends/gfx_metal.h
@@ -138,7 +138,7 @@ class GfxRenderingAPIMetal final : public GfxRenderingAPI {
     void SetScissor(int x, int y, int width, int height) override;
     void SetUseAlpha(bool useAlpha) override;
     void DrawTriangles(float buf_vbo[], size_t buf_vbo_len, size_t buf_vbo_num_tris) override;
-    void Init() override;
+    void Init(Ship::GuiWindowInitData& data) override;
     void OnResize() override;
     void StartFrame() override;
     void EndFrame() override;
diff --git a/src/graphic/Fast3D/backends/gfx_opengl.cpp b/src/graphic/Fast3D/backends/gfx_opengl.cpp
index 32c1bcb..a754252 100644
--- a/src/graphic/Fast3D/backends/gfx_opengl.cpp
+++ b/src/graphic/Fast3D/backends/gfx_opengl.cpp
@@ -651,7 +651,7 @@ void GfxRenderingAPIOGL::DrawTriangles(float buf_vbo[], size_t buf_vbo_len, size
     glDrawArrays(GL_TRIANGLES, 0, 3 * buf_vbo_num_tris);
 }
 
-void GfxRenderingAPIOGL::Init() {
+void GfxRenderingAPIOGL::Init(Ship::GuiWindowInitData& init_data) {
 #ifndef __linux__
     glewInit();
 #endif
diff --git a/src/graphic/Fast3D/backends/gfx_opengl.h b/src/graphic/Fast3D/backends/gfx_opengl.h
index be7356b..3148d31 100644
--- a/src/graphic/Fast3D/backends/gfx_opengl.h
+++ b/src/graphic/Fast3D/backends/gfx_opengl.h
@@ -71,7 +71,7 @@ class GfxRenderingAPIOGL final : public GfxRenderingAPI {
     void SetScissor(int x, int y, int width, int height) override;
     void SetUseAlpha(bool useAlpha) override;
     void DrawTriangles(float buf_vbo[], size_t buf_vbo_len, size_t buf_vbo_num_tris) override;
-    void Init() override;
+    void Init(Ship::GuiWindowInitData& init_data) override;
     void OnResize() override;
     void StartFrame() override;
     void EndFrame() override;
diff --git a/src/graphic/Fast3D/backends/gfx_rendering_api.h b/src/graphic/Fast3D/backends/gfx_rendering_api.h
index 086b95c..649e29f 100644
--- a/src/graphic/Fast3D/backends/gfx_rendering_api.h
+++ b/src/graphic/Fast3D/backends/gfx_rendering_api.h
@@ -7,6 +7,8 @@
 #include <set>
 #include "imconfig.h"
 
+#include "window/gui/Gui.h"
+
 namespace Fast {
 struct ShaderProgram;
 
@@ -49,7 +51,7 @@ class GfxRenderingAPI {
     virtual void SetScissor(int x, int y, int width, int height) = 0;
     virtual void SetUseAlpha(bool useAlpha) = 0;
     virtual void DrawTriangles(float buf_vbo[], size_t buf_vbo_len, size_t buf_vbo_num_tris) = 0;
-    virtual void Init() = 0;
+    virtual void Init(Ship::GuiWindowInitData& init_data) = 0;
     virtual void OnResize() = 0;
     virtual void StartFrame() = 0;
     virtual void EndFrame() = 0;
diff --git a/src/graphic/Fast3D/backends/gfx_sdl.h b/src/graphic/Fast3D/backends/gfx_sdl.h
index 2ee428c..38cbb6d 100644
--- a/src/graphic/Fast3D/backends/gfx_sdl.h
+++ b/src/graphic/Fast3D/backends/gfx_sdl.h
@@ -1,6 +1,7 @@
 #ifndef GFX_SDL_H
 #define GFX_SDL_H
 
+#include "window/gui/Gui.h"
 #include "gfx_window_manager_api.h"
 namespace Fast {
 class GfxWindowBackendSDL2 final : public GfxWindowBackend {
@@ -8,7 +9,7 @@ class GfxWindowBackendSDL2 final : public GfxWindowBackend {
     GfxWindowBackendSDL2() = default;
     ~GfxWindowBackendSDL2() override;
 
-    void Init(const char* gameName, const char* apiName, bool startFullScreen, uint32_t width, uint32_t height,
+    Ship::GuiWindowInitData Init(const char* gameName, const char* apiName, bool startFullScreen, uint32_t width, uint32_t height,
               int32_t posX, int32_t posY) override;
     void Close() override;
     void SetKeyboardCallbacks(bool (*onKeyDown)(int scancode), bool (*onKeyUp)(int scancode),
diff --git a/src/graphic/Fast3D/backends/gfx_sdl2.cpp b/src/graphic/Fast3D/backends/gfx_sdl2.cpp
index 8cc690a..be2255c 100644
--- a/src/graphic/Fast3D/backends/gfx_sdl2.cpp
+++ b/src/graphic/Fast3D/backends/gfx_sdl2.cpp
@@ -26,8 +26,10 @@
 #else
 #include <SDL2/SDL.h>
 #define GL_GLEXT_PROTOTYPES 1
+#ifndef WIN32
 #include <SDL2/SDL_opengles2.h>
 #endif
+#endif
 
 #include "window/gui/Gui.h"
 #include "public/bridge/consolevariablebridge.h"
@@ -35,8 +37,17 @@
 #ifdef _WIN32
 #include <WTypesbase.h>
 #include <Windows.h>
+#endif
+
 #include <SDL_syswm.h>
+#include <LLGL/LLGL.h>
+#include "gfx_llgl.h"
+#include "gfx_sdl.h"
+
+#ifdef __APPLE__
+typedef void NSResponder;
 #endif
+#include <LLGL/Platform/NativeHandle.h>
 
 #define GFX_BACKEND_NAME "SDL"
 #define _100NANOSECONDS_IN_SECOND 10000000
@@ -309,7 +320,7 @@ static LRESULT CALLBACK gfx_sdl_wnd_proc(HWND h_wnd, UINT message, WPARAM w_para
 };
 #endif
 
-void GfxWindowBackendSDL2::Init(const char* gameName, const char* gfxApiName, bool startFullScreen, uint32_t width,
+Ship::GuiWindowInitData GfxWindowBackendSDL2::Init(const char* gameName, const char* gfxApiName, bool startFullScreen, uint32_t width,
                                 uint32_t height, int32_t posX, int32_t posY) {
     mWindowWidth = width;
     mWindowHeight = height;
@@ -323,6 +334,21 @@ void GfxWindowBackendSDL2::Init(const char* gameName, const char* gfxApiName, bo
 
     SDL_EventState(SDL_DROPFILE, SDL_ENABLE);
 
+    char title[512];
+    int len = snprintf(title, 512, "%s (%s)", "MM","LLGL");
+
+    Ship::GuiWindowInitData window_impl{};
+    bool use_llgl = true;
+    if (use_llgl) {
+        window_impl.LLGL = { std::make_shared<SDLSurface>(
+                                 LLGL::Extent2D{ (uint32_t)mWindowWidth, (uint32_t)mWindowHeight }, title,
+                                 LLGL::RendererID::OpenGL, window_impl.LLGL.desc),
+                             window_impl.LLGL.desc };
+        mWnd = window_impl.LLGL.Window->wnd;
+        return window_impl;
+    }
+
+
 #if defined(__APPLE__)
     bool use_opengl = strcmp(gfxApiName, "OpenGL") == 0;
 #else
@@ -353,8 +379,7 @@ void GfxWindowBackendSDL2::Init(const char* gameName, const char* gfxApiName, bo
     }
 #endif
 
-    char title[512];
-    int len = sprintf(title, "%s (%s)", gameName, gfxApiName);
+    len = sprintf(title, "%s (%s)", gameName, gfxApiName);
 
 #ifdef __IOS__
     Uint32 flags = SDL_WINDOW_BORDERLESS | SDL_WINDOW_SHOWN;
@@ -379,8 +404,6 @@ void GfxWindowBackendSDL2::Init(const char* gameName, const char* gfxApiName, bo
     SDL_WndProc = SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)gfx_sdl_wnd_proc);
     SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
 #endif
-    Ship::GuiWindowInitData window_impl;
-
     int display_in_use = SDL_GetWindowDisplayIndex(mWnd);
     if (display_in_use < 0) { // Fallback to default if out of bounds
         posX = 100;
@@ -408,7 +431,7 @@ void GfxWindowBackendSDL2::Init(const char* gameName, const char* gfxApiName, bo
         mRenderer = SDL_CreateRenderer(mWnd, -1, flags);
         if (mRenderer == nullptr) {
             SPDLOG_ERROR("Error creating renderer: {}", SDL_GetError());
-            return;
+            return window_impl;
         }
 
         if (startFullScreen) {
@@ -576,11 +599,13 @@ void GfxWindowBackendSDL2::HandleSingleEvent(SDL_Event& event) {
         case SDL_WINDOWEVENT:
             switch (event.window.event) {
                 case SDL_WINDOWEVENT_SIZE_CHANGED:
+                    case SDL_WINDOWEVENT_RESIZED:
 #ifdef __APPLE__
                     SDL_GetWindowSize(mWnd, &mWindowWidth, &mWindowHeight);
 #else
                     SDL_GL_GetDrawableSize(mWnd, &mWindowWidth, &mWindowHeight);
 #endif
+                llgl_swapChain->ResizeBuffers({ (uint32_t)mWindowWidth, (uint32_t)mWindowWidth });
                     break;
                 case SDL_WINDOWEVENT_CLOSE:
                     if (event.window.windowID == SDL_GetWindowID(mWnd)) {
@@ -684,7 +709,8 @@ void GfxWindowBackendSDL2::SwapBuffersBegin() {
     }
 
     SyncFramerateWithTime();
-    SDL_GL_SwapWindow(mWnd);
+    //! TODO: Implement this
+    // SDL_GL_SwapWindow(wnd);
 }
 
 void GfxWindowBackendSDL2::SwapBuffersEnd() {
diff --git a/src/graphic/Fast3D/backends/gfx_window_manager_api.h b/src/graphic/Fast3D/backends/gfx_window_manager_api.h
index e793e6c..7ccc4e8 100644
--- a/src/graphic/Fast3D/backends/gfx_window_manager_api.h
+++ b/src/graphic/Fast3D/backends/gfx_window_manager_api.h
@@ -3,11 +3,12 @@
 
 #include <stdint.h>
 #include <stdbool.h>
+#include "window/gui/Gui.h"
 namespace Fast {
 class GfxWindowBackend {
   public:
     virtual ~GfxWindowBackend() = default;
-    virtual void Init(const char* gameName, const char* apiName, bool startFullScreen, uint32_t width, uint32_t height,
+    virtual Ship::GuiWindowInitData Init(const char* gameName, const char* apiName, bool startFullScreen, uint32_t width, uint32_t height,
                       int32_t posX, int32_t posY) = 0;
     virtual void Close() = 0;
     virtual void SetKeyboardCallbacks(bool (*mOnKeyDown)(int scancode), bool (*mOnKeyUp)(int scancode),
diff --git a/src/graphic/Fast3D/interpreter.cpp b/src/graphic/Fast3D/interpreter.cpp
index 607909e..1672b71 100644
--- a/src/graphic/Fast3D/interpreter.cpp
+++ b/src/graphic/Fast3D/interpreter.cpp
@@ -34,7 +34,7 @@
 #include "utils/Utils.h"
 #include "Context.h"
 #include "libultraship/bridge.h"
-
+#include "window/gui/Gui.h"
 #include <spdlog/fmt/fmt.h>
 
 std::stack<std::string> currentDir;
@@ -4173,8 +4173,8 @@ void Interpreter::Init(class GfxWindowBackend* wapi, class GfxRenderingAPI* rapi
                        bool start_in_fullscreen, uint32_t width, uint32_t height, uint32_t posX, uint32_t posY) {
     mWapi = wapi;
     mRapi = rapi;
-    mWapi->Init(game_name, rapi->GetName(), start_in_fullscreen, width, height, posX, posY);
-    mRapi->Init();
+    auto windowImpl = mWapi->Init(game_name, rapi->GetName(), start_in_fullscreen, width, height, posX, posY);
+    mRapi->Init(windowImpl);
     mRapi->UpdateFramebufferParameters(0, width, height, 1, false, true, true, true);
     mCurDimensions.internal_mul = CVarGetFloat(CVAR_INTERNAL_RESOLUTION, 1);
     mMsaaLevel = CVarGetInteger(CVAR_MSAA_VALUE, 1);
@@ -4287,6 +4287,7 @@ void Interpreter::StartFrame() {
     }
 
     mFbActive = false;
+    mRapi->StartFrame();
 }
 
 GfxExecStack g_exec_stack = {};
diff --git a/src/graphic/Fast3D/shaders/opengl/default.shader.fs b/src/graphic/Fast3D/shaders/opengl/default.shader.fs
index 404caae..bae630b 100644
--- a/src/graphic/Fast3D/shaders/opengl/default.shader.fs
+++ b/src/graphic/Fast3D/shaders/opengl/default.shader.fs
@@ -1,54 +1,50 @@
 @prism(type='fragment', name='Fast3D Fragment Shader', version='1.0.0', description='Ported shader to prism', author='Emill & Prism Team')
 
-@{GLSL_VERSION}
+#version 450 core
 
-@if(core_opengl || opengles)
-out vec4 vOutColor;
-@end
+@if(o_textures[0]) layout(binding = @{get_binding_index()}) uniform sampler2D uTex0;
+@if(o_textures[1]) layout(binding = @{get_binding_index()}) uniform sampler2D uTex1;
+
+if(o_masks[0]) layout(binding = @{get_binding_index()}) uniform sampler2D uTexMask0;
+@if(o_masks[1]) layout(binding = @{get_binding_index()}) uniform sampler2D uTexMask1;
+
+@if(o_blend[0]) layout(binding = @{get_binding_index()}) uniform sampler2D uTexBlend0;
+@if(o_blend[1]) layout(binding = @{get_binding_index()}) uniform sampler2D uTexBlend1;
+
+layout(std140, binding = @{get_binding_index()}) uniform FrameCount {
+    int frame_count;
+};
+layout(std140, binding = @{get_binding_index()}) uniform NoiseScale {
+    float noise_scale;
+};
 
 @for(i in 0..2)
     @if(o_textures[i])
-        @{attr} vec2 vTexCoord@{i};
+        layout(location = @{get_input_location()}) in vec2 vTexCoord@{i};
         @for(j in 0..2)
             @if(o_clamp[i][j])
                 @if(j == 0)
-                    @{attr} float vTexClampS@{i};
+                    layout(location = @{get_input_location()}) in float vTexClampS@{i};
                 @else
-                    @{attr} float vTexClampT@{i};
+                    layout(location = @{get_input_location()}) in float vTexClampT@{i};
                 @end
             @end
         @end
     @end
 @end
 
-@if(o_fog) @{attr} vec4 vFog;
-@if(o_grayscale) @{attr} vec4 vGrayscaleColor;
+@if(o_fog) layout(location = @{get_input_location()}) in vec4 vFog;
+if(o_grayscale) layout(location = @{get_input_location()}) in vec4 vGrayscaleColor;
 
 @for(i in 0..o_inputs)
     @if(o_alpha)
-        @{attr} vec4 vInput@{i + 1};
+        layout(location = @{get_input_location()}) in vec4 vInput@{i + 1};
     @else
-        @{attr} vec3 vInput@{i + 1};
+        layout(location = @{get_input_location()}) in vec3 vInput@{i + 1};
     @end
 @end
 
-@if(o_textures[0]) uniform sampler2D uTex0;
-@if(o_textures[1]) uniform sampler2D uTex1;
-
-@if(o_masks[0]) uniform sampler2D uTexMask0;
-@if(o_masks[1]) uniform sampler2D uTexMask1;
 
-@if(o_blend[0]) uniform sampler2D uTexBlend0;
-@if(o_blend[1]) uniform sampler2D uTexBlend1;
-
-uniform int frame_count;
-uniform float noise_scale;
-
-uniform int texture_width[2];
-uniform int texture_height[2];
-uniform int texture_filtering[2];
-
-#define TEX_OFFSET(off) @{texture}(tex, texCoord - off / texSize)
 #define WRAP(x, low, high) mod((x)-(low), (high)-(low)) + (low)
 
 float random(in vec3 value) {
@@ -78,11 +74,13 @@ vec4 hookTexture2D(in int id, sampler2D tex, in vec2 uv, in vec2 texSize) {
         return filter3point(tex, uv, texSize);
     }
 @end
-    return @{texture}(tex, uv);
+    return texture(tex, uv);
 }
 
 #define TEX_SIZE(tex) vec2(texture_width[tex], texture_height[tex])
 
+layout(location = 0) out vec4 fragColor;
+
 void main() {
     @for(i in 0..2)
         @if(o_textures[i])
@@ -106,11 +104,7 @@ void main() {
             vec4 texVal@{i} = hookTexture2D(@{i}, uTex@{i}, vTexCoordAdj@{i}, texSize@{i});
 
             @if(o_masks[i])
-                @if(opengles) 
-                    vec2 maskSize@{i} = vec2(textureSize(uTexMask@{i}, 0));
-                @else 
-                    vec2 maskSize@{i} = textureSize(uTexMask@{i}, 0);
-                @end
+                vec2 maskSize@{i} = textureSize(uTexMask@{i}, 0);
 
                 vec4 maskVal@{i} = hookTexture2D(@{i}, uTexMask@{i}, vTexCoordAdj@{i}, maskSize@{i});
 
@@ -200,12 +194,12 @@ void main() {
         @if(o_invisible)
             texel.a = 0.0;
         @end
-        @{vOutColor} = texel;
+        fragColor= texel;
     @else
-        @{vOutColor} = vec4(texel, 1.0);
+        fragColor = vec4(texel, 1.0);
     @end
 
     @if(srgb_mode)
-        @{vOutColor} = fromLinear(@{vOutColor});
+        fragColor = fromLinear(fragColor);
     @end
 }
\ No newline at end of file
diff --git a/src/graphic/Fast3D/shaders/opengl/default.shader.vs b/src/graphic/Fast3D/shaders/opengl/default.shader.vs
index cf0f627..7db3af8 100644
--- a/src/graphic/Fast3D/shaders/opengl/default.shader.vs
+++ b/src/graphic/Fast3D/shaders/opengl/default.shader.vs
@@ -1,53 +1,51 @@
 @prism(type='fragment', name='Fast3D Fragment Shader', version='1.0.0', description='Ported shader to prism', author='Emill & Prism Team')
 
-@{GLSL_VERSION}
+#version 450 core
 
-@{attr} vec4 aVtxPos;
+layout(location = @{get_input_location()}) in vec4 aVtxPos;
 
 @for(i in 0..2)
     @if(o_textures[i])
-        @{attr} vec2 aTexCoord@{i};
-        @{out} vec2 vTexCoord@{i};
-        @{update_floats(2)}
+        layout(location = @{get_input_location()}) in vec2 aTexCoord@{i};
+        layout(location = @{get_output_location()}) out vec2 vTexCoord@{i};
         @for(j in 0..2)
             @if(o_clamp[i][j])
                 @if(j == 0)
-                    @{attr} float aTexClampS@{i};
-                    @{out} float vTexClampS@{i};
+                    layout(location = @{get_input_location()}) in float aTexClampS@{i};
+                    layout(location = @{get_output_location()}) out float vTexClampS@{i};
                 @else
-                    @{attr} float aTexClampT@{i};
-                    @{out} float vTexClampT@{i};
+                    layout(location = @{get_input_location()}) in float aTexClampT@{i};
+                    layout(location = @{get_output_location()}) out float vTexClampT@{i};
                 @end
-                @{update_floats(1)}
             @end
         @end
     @end
 @end
 
 @if(o_fog)
-    @{attr} vec4 aFog;
-    @{out} vec4 vFog;
-    @{update_floats(4)}
+    layout(location = @{get_input_location()}) in vec4 aFog;
+    layout(location = @{get_output_location()}) out vec4 vFog;
 @end
 
 @if(o_grayscale)
-    @{attr} vec4 aGrayscaleColor;
-    @{out} vec4 vGrayscaleColor;
-    @{update_floats(4)}
+    layout(location = @{get_input_location()}) in vec4 aGrayscaleColor;
+    layout(location = @{get_output_location()}) out vec4 vGrayscaleColor;
 @end
 
 @for(i in 0..o_inputs)
     @if(o_alpha)
-        @{attr} vec4 aInput@{i + 1};
-        @{out} vec4 vInput@{i + 1};
-        @{update_floats(4)}
+        layout(location = @{get_input_location()}) in vec4 aInput@{i + 1};
+        layout(location = @{get_output_location()}) out vec4 vInput@{i + 1};
     @else
-        @{attr} vec3 aInput@{i + 1};
-        @{out} vec3 vInput@{i + 1};
-        @{update_floats(3)}
+        layout(location = @{get_input_location()}) in vec3 aInput@{i + 1};
+        layout(location = @{get_output_location()}) out vec3 vInput@{i + 1};
     @end
 @end
 
+out gl_PerVertex {
+    vec4 gl_Position;
+};
+
 void main() {
      @for(i in 0..2)
         @if(o_textures[i])
@@ -73,7 +71,4 @@ void main() {
         vInput@{i + 1} = aInput@{i + 1};
     @end
     gl_Position = aVtxPos;
-    @if(opengles)
-        gl_Position.z *= 0.3f;
-    @end
 }
\ No newline at end of file
diff --git a/src/window/Window.h b/src/window/Window.h
index bb12974..40b49af 100644
--- a/src/window/Window.h
+++ b/src/window/Window.h
@@ -10,7 +10,7 @@
 #include "controller/controldevice/controller/mapping/keyboard/KeyboardScancodes.h"
 
 namespace Ship {
-enum class WindowBackend { FAST3D_DXGI_DX11, FAST3D_SDL_OPENGL, FAST3D_SDL_METAL, WINDOW_BACKEND_COUNT };
+enum class WindowBackend { FAST3D_DXGI_DX11, FAST3D_SDL_OPENGL, FAST3D_SDL_METAL, FAST3D_SDL_LLGL, WINDOW_BACKEND_COUNT, };
 
 struct Coords {
     int32_t x;
diff --git a/src/window/gui/Gui.cpp b/src/window/gui/Gui.cpp
index 208eeef..87d8ba2 100644
--- a/src/window/gui/Gui.cpp
+++ b/src/window/gui/Gui.cpp
@@ -2,6 +2,13 @@
 
 #include "Gui.h"
 
+
+#include "ImGui_LLGL.h"
+#include "graphic/Fast3D/backends/gfx_llgl.h"
+
+#include <SDL2/SDL_video.h>
+#include <SDL2/SDL_syswm.h>
+
 #include <cstring>
 #include <utility>
 #include <string>
@@ -173,6 +180,9 @@ void Gui::ImGuiWMInit() {
             ImGui_ImplWin32_Init(mImpl.Dx11.Window);
             break;
 #endif
+        case WindowBackend::FAST3D_SDL_LLGL:
+            InitImGui(*mImpl.LLGL.Window, llgl_renderer, llgl_swapChain, llgl_cmdBuffer);
+        break;
         default:
             break;
     }
@@ -326,6 +336,9 @@ void Gui::ImGuiBackendNewFrame() {
             break;
         }
 #endif
+        case WindowBackend::FAST3D_SDL_LLGL:
+            NewFrameImGui(llgl_renderer, llgl_cmdBuffer);
+        break;
         default:
             break;
     }
@@ -554,13 +567,18 @@ void Gui::HandleMouseCapture() {
     }
 }
 
-void Gui::StartFrame() {
-    HandleMouseCapture();
+void Gui::ImGuiNewFrame() {
     ImGuiBackendNewFrame();
     ImGuiWMNewFrame();
     ImGui::NewFrame();
 }
 
+void Gui::StartFrame() {
+    HandleMouseCapture();
+}
+
+
+
 void Gui::EndFrame() {
     // Draw the ImGui "viewports" which are the floating windows.
     ImGui::Render();
@@ -721,13 +739,15 @@ void Gui::CheckSaveCvars() {
 void Gui::StartDraw() {
     // Initialize the frame.
     StartFrame();
-    // Draw the gui menus
-    DrawMenu();
-    // Calculate the available space the game can render to
-    CalculateGameViewport();
+
 }
 
 void Gui::EndDraw() {
+    // Draw the gui menus
+    ImGui::NewFrame();
+    // Calculate the available space the game can render to
+    CalculateGameViewport();
+    DrawMenu();
     // Draw the game framebuffer into ImGui
     DrawGame();
     // End the frame
@@ -784,6 +804,9 @@ void Gui::ImGuiRenderDrawData(ImDrawData* data) {
             ImGui_ImplDX11_RenderDrawData(data);
             break;
 #endif
+        case WindowBackend::FAST3D_SDL_LLGL:
+            RenderImGui(data, llgl_renderer, llgl_cmdBuffer);
+            break;
         default:
             break;
     }
diff --git a/src/window/gui/Gui.h b/src/window/gui/Gui.h
index 5b1b1e1..3e85092 100644
--- a/src/window/gui/Gui.h
+++ b/src/window/gui/Gui.h
@@ -22,34 +22,39 @@
 #include "resource/type/Texture.h"
 #include "window/gui/resource/GuiTexture.h"
 
+#include <LLGL/LLGL.h>
+
 namespace Fast {
 class Interpreter;
 }
 
+#include "sdl_llgl.h"
+
 namespace Ship {
 
 typedef struct {
-    union {
-        struct {
-            void* Window;
-            void* DeviceContext;
-            void* Device;
-        } Dx11;
-        struct {
-            void* Window;
-            void* Context;
-        } Opengl;
-        struct {
-            void* Window;
-            SDL_Renderer* Renderer;
-        } Metal;
-        struct {
-            uint32_t Width;
-            uint32_t Height;
-        } Gx2;
-    };
+    struct {
+        void* Window;
+        void* DeviceContext;
+        void* Device;
+    } Dx11;
+    struct {
+        void* Window;
+        void* Context;
+    } Opengl;
+    struct {
+        void* Window;
+        SDL_Renderer* Renderer;
+    } Metal;
+    struct {
+        std::shared_ptr<SDLSurface> Window;
+        LLGL::RenderSystemDescriptor desc;
+    } LLGL;
+    struct {
+        uint32_t Width;
+        uint32_t Height;
+    } Gx2;
 } GuiWindowInitData;
-
 typedef union {
     struct {
         void* Handle;
@@ -68,10 +73,11 @@ typedef union {
 class Gui {
   public:
     Gui();
-    Gui(std::vector<std::shared_ptr<GuiWindow>> guiWindows);
+    explicit Gui(std::vector<std::shared_ptr<GuiWindow>> guiWindows);
     virtual ~Gui();
 
     void Init(GuiWindowInitData windowImpl);
+    void ImGuiNewFrame();
     void StartDraw();
     void EndDraw();
     void HandleWindowEvents(WindowEvent event);
