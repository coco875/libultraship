diff --git a/CMakeLists.txt b/CMakeLists.txt
index 0cefdbd..c3641a4 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -94,6 +94,11 @@ if(NOT BGFX_DIR)
 elseif(NOT IS_ABSOLUTE "${BGFX_DIR}")
 	get_filename_component(BGFX_DIR "${BGFX_DIR}" REALPATH BASE_DIR "${CMAKE_CURRENT_SOURCE_DIR}")
 endif()
+if( NOT BRTSHADERC_DIR )
+	set( BRTSHADERC_DIR "${CMAKE_CURRENT_SOURCE_DIR}/brtshaderc" CACHE STRING "Location of brtshaderc." )
+elseif( NOT IS_ABSOLUTE "${BRTSHADERC_DIR}")
+	get_filename_component(BRTSHADERC_DIR "${BRTSHADERC_DIR}" REALPATH BASE_DIR "${CMAKE_CURRENT_SOURCE_DIR}")
+endif()
 
 file(TO_CMAKE_PATH "${BX_DIR}" BX_DIR)
 file(TO_CMAKE_PATH "${BIMG_DIR}" BIMG_DIR)
diff --git a/brtshaderc/brtshaderc.cpp b/brtshaderc/brtshaderc.cpp
new file mode 100644
index 0000000..950e1c3
--- /dev/null
+++ b/brtshaderc/brtshaderc.cpp
@@ -0,0 +1,515 @@
+#include <cstdio>
+#include <bx/file.h>
+#include <vector>
+
+namespace bgfx
+{
+    typedef void(*UserErrorFn)(void*, const char*, va_list);
+    static UserErrorFn s_user_error_fn = nullptr;
+    static void* s_user_error_ptr = nullptr;
+    void setShaderCErrorFunction(UserErrorFn fn, void* user_ptr)
+    {
+        s_user_error_fn = fn;
+        s_user_error_ptr = user_ptr;
+    }
+}
+
+void printError(FILE* file, const char* format, ...)
+{
+    va_list args;
+    va_start(args, format);
+    if (bgfx::s_user_error_fn)
+    {
+        bgfx::s_user_error_fn(bgfx::s_user_error_ptr, format, args);
+    }
+    else
+    {
+        vfprintf(file, format, args);
+    }
+    va_end(args);
+}
+
+// hack to defined stuff
+#define fprintf printError
+#define main fakeMain
+#define g_allocator g_shaderc_allocator
+
+// fix warnings
+// #undef BX_TRACE
+// #undef BX_WARN
+// #undef BX_CHECK
+
+// include original shaderc code files
+#include "shaderc.cpp"
+//#define static_allocate static_allocate_shaderc
+//#define static_deallocate static_deallocate_shaderc
+//#include "../shaderc/shaderc_spirv.cpp"
+//#include "../shaderc/shaderc_pssl.cpp"
+
+#include "brtshaderc.h"
+using namespace bgfx;
+
+namespace shaderc
+{
+    /// not a real FileWriter, but a hack to redirect write() to a memory block.
+    class BufferWriter : public bx::FileWriter
+    {
+    public:
+
+        BufferWriter()
+        {
+        }
+
+        ~BufferWriter()
+        {
+        }
+
+        bool open(const bx::FilePath& _filePath, bool _append, bx::Error* _err) override
+        {
+            return true;
+        }
+
+        const bgfx::Memory* finalize()
+        {
+            if(_buffer.size() > 0)
+            {
+                _buffer.push_back('\0');
+
+                const bgfx::Memory* mem = bgfx::alloc(_buffer.size());
+                bx::memCopy(mem->data, _buffer.data(), _buffer.size());
+                return mem;
+            }
+
+            return nullptr;
+        }
+
+        int32_t write(const void* _data, int32_t _size, bx::Error* _err) override
+        {
+            const char* data = (const char*)_data;
+            _buffer.insert(_buffer.end(), data, data+_size);
+            return _size;
+        }
+
+    private:
+        BX_ALIGN_DECL(16, uint8_t) m_internal[64];
+        typedef std::vector<uint8_t> Buffer;
+        Buffer _buffer;
+    };
+
+    const char* getProfile(bgfx::RendererType::Enum rendererType, ShaderType shaderType)
+    {
+        switch(rendererType)
+        {
+        default:
+        case bgfx::RendererType::Noop:         //!< No rendering.
+            break;
+        case bgfx::RendererType::Direct3D11:   //!< Direct3D 11.0
+        {
+            if(shaderType == 'v')
+                return "vs_4_0";
+            else if(shaderType == 'f')
+                return "ps_4_0";
+            else if(shaderType == 'c')
+                return "cs_5_0";
+        }
+        break;
+        case bgfx::RendererType::Direct3D12:   //!< Direct3D 12.0
+        {
+            if(shaderType == 'v')
+                return "vs_5_0";
+            else if(shaderType == 'f')
+                return "ps_5_0";
+            else if(shaderType == 'c')
+                return "cs_5_0";
+        }
+        case bgfx::RendererType::Gnm:          //!< GNM
+            break;
+        case bgfx::RendererType::Metal:        //!< Metal
+            break;
+        case bgfx::RendererType::OpenGLES:     //!< OpenGL ES 2.0+
+            break;
+        case bgfx::RendererType::OpenGL:       //!< OpenGL 2.1+
+        {
+            if(shaderType == 'v' || shaderType == 'f')
+                return "120";
+            else if(shaderType == 'c')
+                return "430";
+        }
+        break;
+        case bgfx::RendererType::Vulkan:       //!< Vulkan
+            break;
+        };
+
+        return NULL;
+    }
+
+    const bgfx::Memory* compileShader(ShaderType shaderType, const char* filePath, const char* defines, const char* varyingPath, const char* profile)
+    {
+        bgfx::Options options;
+
+        options.inputFilePath = filePath;
+        options.shaderType = shaderType;
+
+        // set platform
+#if BX_PLATFORM_LINUX
+        options.platform = "linux";
+#elif BX_PLATFORM_WINDOWS
+        options.platform = "windows";
+#elif BX_PLATFORM_ANDROID
+        options.platform = "android";
+#elif BX_PLATFORM_EMSCRIPTEN
+        options.platform = "asm.js";
+#elif BX_PLATFORM_IOS
+        options.platform = "ios";
+#elif BX_PLATFORM_OSX
+        options.platform = "osx";
+#endif
+
+        // set profile
+        if (profile)
+        {
+            // user profile
+            options.profile = profile;
+        }
+        else
+        {
+            // set default profile for current running renderer.
+            bgfx::RendererType::Enum rendererType = bgfx::getRendererType();
+            options.profile = getProfile(rendererType, shaderType);
+        }
+
+        // include current dir
+        std::string dir;
+        {
+            bx::FilePath fp(filePath);
+            bx::StringView path(fp.getPath());
+
+            std::string str = std::string(path.getPtr());
+
+            dir.assign(path.getPtr(), path.getTerm());
+            options.includeDirs.push_back(dir);
+        }
+
+        // set defines
+        while (NULL != defines && '\0' != *defines)
+        {
+            defines = bx::strLTrimSpace(defines).getPtr();
+            bx::StringView eol = bx::strFind(defines, ';');
+            std::string define(defines, eol.getPtr() );
+            options.defines.push_back(define.c_str() );
+            defines = ';' == *eol.getPtr() ? eol.getPtr()+1 : eol.getPtr();
+        }
+
+        // set varyingdef
+        std::string defaultVarying = dir + "varying.def.sc";
+        const char* varyingdef = varyingPath ? varyingPath : defaultVarying.c_str();
+        auto attribdef = bgfx::File();
+        attribdef.load(varyingdef);
+        const char* parse = attribdef.getData();
+        if (NULL != parse && *parse != '\0')
+        {
+            options.dependencies.push_back(varyingdef);
+        }
+        else
+        {
+            fprintf(stderr, "ERROR: Failed to parse varying def file: \"%s\" No input/output semantics will be generated in the code!\n", varyingdef);
+            return nullptr;
+        }
+
+        // read shader source file
+        bx::FileReader reader;
+        if (!bx::open(&reader, filePath))
+        {
+            fprintf(stderr, "Unable to open file '%s'.\n", filePath);
+            return nullptr;
+        }
+
+        // add padding
+        const size_t padding = 16384;
+        uint32_t size = (uint32_t)bx::getSize(&reader);
+        char* data = new char[size + padding + 1];
+        size = (uint32_t)bx::read(&reader, data, size, NULL);
+
+        if (data[0] == '\xef'
+        &&  data[1] == '\xbb'
+        &&  data[2] == '\xbf')
+        {
+            bx::memMove(data, &data[3], size-3);
+            size -= 3;
+        }
+
+        // Compiler generates "error X3000: syntax error: unexpected end of file"
+        // if input doesn't have empty line at EOF.
+        data[size] = '\n';
+        bx::memSet(&data[size+1], 0, padding);
+        bx::close(&reader);
+
+
+        std::string commandLineComment = "// shaderc command line:\n";
+
+        // compile shader.
+
+        BufferWriter writer;
+        if ( bgfx::compileShader(attribdef.getData(), commandLineComment.c_str(), data, size, options, &writer, bx::getStdOut()) )
+        {
+            // this will copy the compiled shader data to a memory block and return mem ptr
+            return writer.finalize();
+        }
+
+        return nullptr;
+    }
+
+    void help(const char* _error = NULL)
+    {
+        if (NULL != _error)
+        {
+            fprintf(stderr, "brtshaderc error:\n%s\n\n", _error);
+        }
+    }
+
+    bx::StringView baseName(const char* _filePath)
+    {
+        bx::FilePath fp(_filePath);
+        return bx::strFind(_filePath, fp.getBaseName() );
+    }
+
+    int compileShader(int _argc, const char* _argv[], bx::FileWriter* _writer)
+    {
+        bx::CommandLine cmdLine(_argc, _argv);
+
+        if (cmdLine.hasArg('v', "version") )
+        {
+            fprintf(stderr
+                , "shaderc, bgfx shader compiler tool, version %d.%d.%d.\n"
+                , BGFX_SHADERC_VERSION_MAJOR
+                , BGFX_SHADERC_VERSION_MINOR
+                , BGFX_API_VERSION
+                );
+            return bx::kExitSuccess;
+        }
+
+        if (cmdLine.hasArg('h', "help") )
+        {
+            help();
+            return bx::kExitFailure;
+        }
+
+        //@@g_verbose = cmdLine.hasArg("verbose");
+
+        const char* filePath = cmdLine.findOption('f');
+        if (NULL == filePath)
+        {
+            help("Shader file name must be specified.");
+            return bx::kExitFailure;
+        }
+
+        const char* outFilePath = cmdLine.findOption('o');
+        ///@if (NULL == outFilePath)
+        ///@{
+        ///@    help("Output file name must be specified.");
+        ///@    return bx::kExitFailure;
+        ///@}
+
+        const char* type = cmdLine.findOption('\0', "type");
+        if (NULL == type)
+        {
+            help("Must specify shader type.");
+            return bx::kExitFailure;
+        }
+
+        Options options;
+        options.inputFilePath = filePath;
+        options.outputFilePath = outFilePath;
+        options.shaderType = bx::toLower(type[0]);
+
+        options.disasm = cmdLine.hasArg('\0', "disasm");
+
+        const char* platform = cmdLine.findOption('\0', "platform");
+        if (NULL == platform)
+        {
+            platform = "";
+        }
+
+        options.platform = platform;
+
+        options.raw = cmdLine.hasArg('\0', "raw");
+
+        const char* profile = cmdLine.findOption('p', "profile");
+
+        if ( NULL != profile)
+        {
+            options.profile = profile;
+        }
+
+        {
+            options.debugInformation       = cmdLine.hasArg('\0', "debug");
+            options.avoidFlowControl       = cmdLine.hasArg('\0', "avoid-flow-control");
+            options.noPreshader            = cmdLine.hasArg('\0', "no-preshader");
+            options.partialPrecision       = cmdLine.hasArg('\0', "partial-precision");
+            options.preferFlowControl      = cmdLine.hasArg('\0', "prefer-flow-control");
+            options.backwardsCompatibility = cmdLine.hasArg('\0', "backwards-compatibility");
+            options.warningsAreErrors      = cmdLine.hasArg('\0', "Werror");
+            options.keepIntermediate       = cmdLine.hasArg('\0', "keep-intermediate");
+
+            uint32_t optimization = 3;
+            if (cmdLine.hasArg(optimization, 'O') )
+            {
+                options.optimize = true;
+                options.optimizationLevel = optimization;
+            }
+        }
+
+        ///@const char* bin2c = NULL;
+        ///@if (cmdLine.hasArg("bin2c") )
+        ///@{
+        ///@    bin2c = cmdLine.findOption("bin2c");
+        ///@    if (NULL == bin2c)
+        ///@    {
+        ///@        bin2c = baseName(outFilePath);
+        ///@        uint32_t len = (uint32_t)bx::strLen(bin2c);
+        ///@        char* temp = (char*)alloca(len+1);
+        ///@        for (char *out = temp; *bin2c != '\0';)
+        ///@        {
+        ///@            char ch = *bin2c++;
+        ///@            if (isalnum(ch) )
+        ///@            {
+        ///@                *out++ = ch;
+        ///@            }
+        ///@            else
+        ///@            {
+        ///@                *out++ = '_';
+        ///@            }
+        ///@        }
+        ///@        temp[len] = '\0';
+        ///@
+        ///@        bin2c = temp;
+        ///@    }
+        ///@}
+
+        options.depends = cmdLine.hasArg("depends");
+        options.preprocessOnly = cmdLine.hasArg("preprocess");
+        const char* includeDir = cmdLine.findOption('i');
+
+        BX_TRACE("depends: %d", options.depends);
+        BX_TRACE("preprocessOnly: %d", options.preprocessOnly);
+        BX_TRACE("includeDir: %s", includeDir);
+
+        for (int ii = 1; NULL != includeDir; ++ii)
+        {
+            options.includeDirs.push_back(includeDir);
+            includeDir = cmdLine.findOption(ii, 'i');
+        }
+
+        std::string dir;
+        {
+            bx::FilePath fp(filePath);
+            bx::StringView path(fp.getPath() );
+
+            dir.assign(path.getPtr(), path.getTerm() );
+            options.includeDirs.push_back(dir);
+        }
+
+        const char* defines = cmdLine.findOption("define");
+        while (NULL != defines
+        &&    '\0'  != *defines)
+        {
+            defines = bx::strLTrimSpace(defines).getPtr();
+            bx::StringView eol = bx::strFind(defines, ';');
+            std::string define(defines, eol.getPtr() );
+            options.defines.push_back(define.c_str() );
+            defines = ';' == *eol.getPtr() ? eol.getPtr()+1 : eol.getPtr();
+        }
+
+        std::string commandLineComment = "// shaderc command line:\n//";
+        for (int32_t ii = 0, num = cmdLine.getNum(); ii < num; ++ii)
+        {
+            commandLineComment += " ";
+            commandLineComment += cmdLine.get(ii);
+        }
+        commandLineComment += "\n\n";
+
+        bool compiled = false;
+
+        bx::FileReader reader;
+        if (!bx::open(&reader, filePath) )
+        {
+            fprintf(stderr, "Unable to open file '%s'.\n", filePath);
+        }
+        else
+        {
+            std::string defaultVarying = dir + "varying.def.sc";
+            const char* varyingdef = cmdLine.findOption("varyingdef", defaultVarying.c_str() );
+            auto attribdef = File();
+            attribdef.load(varyingdef);
+            const char* parse = attribdef.getData();
+            if (NULL != parse
+            &&  *parse != '\0')
+            {
+                options.dependencies.push_back(varyingdef);
+            }
+            else
+            {
+                fprintf(stderr, "ERROR: Failed to parse varying def file: \"%s\" No input/output semantics will be generated in the code!\n", varyingdef);
+            }
+
+            const size_t padding    = 16384;
+            uint32_t size = (uint32_t)bx::getSize(&reader);
+            char* data = new char[size+padding+1];
+            size = (uint32_t)bx::read(&reader, data, size, NULL);
+
+            if (data[0] == '\xef'
+            &&  data[1] == '\xbb'
+            &&  data[2] == '\xbf')
+            {
+                bx::memMove(data, &data[3], size-3);
+                size -= 3;
+            }
+
+            // Compiler generates "error X3000: syntax error: unexpected end of file"
+            // if input doesn't have empty line at EOF.
+            data[size] = '\n';
+            bx::memSet(&data[size+1], 0, padding);
+            bx::close(&reader);
+
+            ///@bx::FileWriter* writer = NULL;
+            bx::FileWriter* writer = _writer;
+
+            ///@if (NULL != bin2c)
+            ///@{
+            ///@    writer = new Bin2cWriter(bin2c);
+            ///@}
+            ///@else
+            ///@{
+            ///@    writer = new bx::FileWriter;
+            ///@}
+
+            if (!bx::open(writer, outFilePath) )
+            {
+                fprintf(stderr, "Unable to open output file '%s'.", outFilePath);
+                return bx::kExitFailure;
+            }
+
+            compiled = compileShader(attribdef.getData(), commandLineComment.c_str(), data, size, options, writer, bx::getStdOut());
+
+            bx::close(writer);
+            ///@delete writer;
+        }
+      return 0;
+    }
+
+    const bgfx::Memory* compileShader(int argc, const char* argv[])
+    {
+        BufferWriter writer;
+        int error = compileShader(argc, argv, &writer);
+
+        if(!error)
+        {
+            return writer.finalize();
+        }
+
+        return nullptr;
+    }
+}
+
+// restore previous defines BX_TRACE BX_WARN and BX_CHECK
+#include "shaderc.h"
diff --git a/brtshaderc/brtshaderc.h b/brtshaderc/brtshaderc.h
new file mode 100644
index 0000000..e010a7c
--- /dev/null
+++ b/brtshaderc/brtshaderc.h
@@ -0,0 +1,43 @@
+#ifndef BRTSHADERC_H_HEADER_GUARD
+#define BRTSHADERC_H_HEADER_GUARD
+
+namespace shaderc
+{
+    enum ShaderType
+    {
+        ST_VERTEX      = 'v',   /// vertex
+        ST_FRAGMENT    = 'f',   /// fragment
+        ST_COMPUTE     = 'c',   /// compute
+    };
+
+    /**
+     * Compile a shader from source file and return memory pointer that contains the compiled shader.
+     *
+     * @param type : Shader type to comile (vertex, fragment or compute)
+     * @param filePath : Shader source file path.
+     * @param defines : List of defines semicolon separated ex: "foo=1;bar;baz=1".
+     * @param varyingPath : File path for varying.def.sc, or assume default name is "varying.def.sc" in current dir.
+     * @param profile : shader profile ("ps_4_0", "vs_4_0", ...). If null, library try to set default profile for current context.
+     * @return a memory block of compiled shader ready to use with bgfx::createShader, or null if failed.
+     */
+    const bgfx::Memory* compileShader(ShaderType type, const char* filePath, const char* defines = nullptr, const char* varyingPath = nullptr, const char* profile = nullptr);
+
+    /**
+     * Compile a shader from arguments list (same as shaderc binary version).
+     *
+     * @param argc : Arguments count.
+     * @param argv : Arguments list.
+     * @return a memory block of compiled shader ready to use with bgfx::createShader, or null if failed.
+     */
+    const bgfx::Memory* compileShader(int argc, const char* argv[]);
+
+    /**
+     * Gets the profile code based on the renderer type and shader type.
+     *
+     * @param rendererType : Renderer type.
+     * @param shaderType : Shader type.
+     * @return the profile code.
+     */
+    const char* getProfile(bgfx::RendererType::Enum rendererType, ShaderType shaderType);
+}
+#endif
\ No newline at end of file
diff --git a/brtshaderc/shaderc.cpp b/brtshaderc/shaderc.cpp
new file mode 100644
index 0000000..8b230d8
--- /dev/null
+++ b/brtshaderc/shaderc.cpp
@@ -0,0 +1,2936 @@
+/*
+ * Copyright 2011-2025 Branimir Karadzic. All rights reserved.
+ * License: https://github.com/bkaradzic/bgfx/blob/master/LICENSE
+ */
+
+#include "shaderc.h"
+#include <bx/commandline.h>
+#include <bx/filepath.h>
+
+#define MAX_TAGS 256
+extern "C"
+{
+#include <fpp.h>
+} // extern "C"
+
+#define BGFX_SHADER_BIN_VERSION 11
+#define BGFX_CHUNK_MAGIC_CSH BX_MAKEFOURCC('C', 'S', 'H', BGFX_SHADER_BIN_VERSION)
+#define BGFX_CHUNK_MAGIC_FSH BX_MAKEFOURCC('F', 'S', 'H', BGFX_SHADER_BIN_VERSION)
+#define BGFX_CHUNK_MAGIC_VSH BX_MAKEFOURCC('V', 'S', 'H', BGFX_SHADER_BIN_VERSION)
+
+#define BGFX_SHADERC_VERSION_MAJOR 1
+#define BGFX_SHADERC_VERSION_MINOR 18
+
+namespace bgfx
+{
+	bool g_verbose = false;
+
+	struct ShadingLang
+	{
+		enum Enum
+		{
+			ESSL,
+			GLSL,
+			HLSL,
+			Metal,
+			PSSL,
+			SpirV,
+
+			Count
+		};
+	};
+
+	static const char* s_shadingLangName[] =
+	{
+		"OpenGL ES Shading Language / WebGL (ESSL)",
+		"OpenGL Shading Language (GLSL)",
+		"High-Level Shading Language (HLSL)",
+		"Metal Shading Language (MSL)",
+		"PlayStation Shader Language (PSSL)",
+		"Standard Portable Intermediate Representation - V (SPIR-V)",
+
+		"Unknown?!"
+	};
+	static_assert(BX_COUNTOF(s_shadingLangName) == ShadingLang::Count+1, "ShadingLang::Enum and s_shadingLangName mismatch");
+
+	const char* getName(ShadingLang::Enum _lang)
+	{
+		return s_shadingLangName[_lang];
+	}
+
+	// c - compute
+	// d - domain
+	// f - fragment
+	// g - geometry
+	// h - hull
+	// v - vertex
+	//
+	// OpenGL #version Features Direct3D Features Shader Model
+	// 2.1    120      vf       9.0      vf       2.0
+	// 3.0    130
+	// 3.1    140
+	// 3.2    150      vgf
+	// 3.3    330               10.0     vgf      4.0
+	// 4.0    400      vhdgf
+	// 4.1    410
+	// 4.2    420               11.0     vhdgf+c  5.0
+	// 4.3    430      vhdgf+c
+	// 4.4    440
+	//
+	// Metal Shading Language (MSL) profile naming convention:
+	//  metal<MSL version>-<SPIR-V version>
+	//
+	// See section "Compiler Options Controlling the Language Version" from the
+	// MSL spec for the correlation between MSL version and platform OS version:
+	//	https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf
+	//
+	// MSL version | SPIR-V version | shaderc encoding
+	//    1.0      |       1.0      |      1000         (deprecated)
+	//    1.1      |       1.0      |      1110
+	//    1.2      |       1.0      |      1210
+	//    2.0      |       1.1      |      2011
+	//    2.1      |       1.1      |      2111
+	//    2.2      |       1.1      |      2211
+	//    2.3      |       1.4      |      2314
+	//    2.4      |       1.4      |      2414
+	//    3.0      |       1.4      |      3014
+	//    3.1      |       1.4      |      3114
+	//
+	// SPIR-V profile naming convention:
+	//  spirv<SPIR-V version>-<Vulkan version>
+	//
+	// SPIR-V version | Vulkan version | shaderc encoding
+	//       1.0      |       1.0      |      1010
+	//       1.3      |       1.1      |      1311
+	//       1.4      |       1.1      |      1411
+	//       1.5      |       1.2      |      1512
+	//       1.6      |       1.3      |      1613
+
+	struct Profile
+	{
+		ShadingLang::Enum lang;
+		uint32_t id;
+		const bx::StringLiteral name;
+	};
+
+	static const Profile s_profiles[] =
+	{
+		{  ShadingLang::ESSL,  100,    "100_es"     },
+		{  ShadingLang::ESSL,  300,    "300_es"     },
+		{  ShadingLang::ESSL,  310,    "310_es"     },
+		{  ShadingLang::ESSL,  320,    "320_es"     },
+		{  ShadingLang::HLSL,  400,    "s_4_0"      },
+		{  ShadingLang::HLSL,  500,    "s_5_0"      },
+		{  ShadingLang::Metal, 1210,   "metal"      },
+		{  ShadingLang::Metal, 1000,   "metal10-10" },
+		{  ShadingLang::Metal, 1110,   "metal11-10" },
+		{  ShadingLang::Metal, 1210,   "metal12-10" },
+		{  ShadingLang::Metal, 2011,   "metal20-11" },
+		{  ShadingLang::Metal, 2111,   "metal21-11" },
+		{  ShadingLang::Metal, 2211,   "metal22-11" },
+		{  ShadingLang::Metal, 2314,   "metal23-14" },
+		{  ShadingLang::Metal, 2414,   "metal24-14" },
+		{  ShadingLang::Metal, 3014,   "metal30-14" },
+		{  ShadingLang::Metal, 3114,   "metal31-14" },
+		{  ShadingLang::PSSL,  1000,   "pssl"       },
+		{  ShadingLang::SpirV, 1010,   "spirv"      },
+		{  ShadingLang::SpirV, 1010,   "spirv10-10" },
+		{  ShadingLang::SpirV, 1311,   "spirv13-11" },
+		{  ShadingLang::SpirV, 1411,   "spirv14-11" },
+		{  ShadingLang::SpirV, 1512,   "spirv15-12" },
+		{  ShadingLang::SpirV, 1613,   "spirv16-13" },
+		{  ShadingLang::GLSL,  120,    "120"        },
+		{  ShadingLang::GLSL,  130,    "130"        },
+		{  ShadingLang::GLSL,  140,    "140"        },
+		{  ShadingLang::GLSL,  150,    "150"        },
+		{  ShadingLang::GLSL,  330,    "330"        },
+		{  ShadingLang::GLSL,  400,    "400"        },
+		{  ShadingLang::GLSL,  410,    "410"        },
+		{  ShadingLang::GLSL,  420,    "420"        },
+		{  ShadingLang::GLSL,  430,    "430"        },
+		{  ShadingLang::GLSL,  440,    "440"        },
+	};
+
+	static const char* s_ARB_shader_texture_lod[] =
+	{
+		"texture2DLod",
+		"texture2DArrayLod", // BK - interacts with ARB_texture_array.
+		"texture2DProjLod",
+		"texture2DGrad",
+		"texture2DProjGrad",
+		"texture3DLod",
+		"texture3DProjLod",
+		"texture3DGrad",
+		"texture3DProjGrad",
+		"textureCubeLod",
+		"textureCubeGrad",
+		"shadow2DLod",
+		"shadow2DProjLod",
+		NULL
+		// "texture1DLod",
+		// "texture1DProjLod",
+		// "shadow1DLod",
+		// "shadow1DProjLod",
+	};
+
+	static const char* s_EXT_shader_texture_lod[] =
+	{
+		"texture2DLod",
+		"texture2DProjLod",
+		"textureCubeLod",
+		"texture2DGrad",
+		"texture2DProjGrad",
+		"textureCubeGrad",
+		NULL
+	};
+
+	static const char* s_EXT_shadow_samplers[] =
+	{
+		"shadow2D",
+		"shadow2DProj",
+		"sampler2DShadow",
+		NULL
+	};
+
+	static const char* s_OES_standard_derivatives[] =
+	{
+		"dFdx",
+		"dFdy",
+		"fwidth",
+		NULL
+	};
+
+	static const char* s_OES_texture_3D[] =
+	{
+		"texture3D",
+		"texture3DProj",
+		"texture3DLod",
+		"texture3DProjLod",
+		NULL
+	};
+
+	static const char* s_EXT_gpu_shader4[] =
+	{
+		"gl_VertexID",
+		"gl_InstanceID",
+		"texture2DLodOffset",
+		NULL
+	};
+
+	// To be use from vertex program require:
+	// https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_shader_viewport_layer_array.txt
+	// DX11 11_1 feature level
+	static const char* s_ARB_shader_viewport_layer_array[] =
+	{
+		"gl_ViewportIndex",
+		"gl_Layer",
+		NULL
+	};
+
+	static const char* s_ARB_gpu_shader5[] =
+	{
+		"bitfieldReverse",
+		"floatBitsToInt",
+		"floatBitsToUint",
+		"intBitsToFloat",
+		"uintBitsToFloat",
+		NULL
+	};
+
+	static const char* s_ARB_shading_language_packing[] =
+	{
+		"packHalf2x16",
+		"unpackHalf2x16",
+		NULL
+	};
+
+	static const char* s_130[] =
+	{
+		"uint",
+		"uint2",
+		"uint3",
+		"uint4",
+		"isampler2D",
+		"usampler2D",
+		"isampler3D",
+		"usampler3D",
+		"isamplerCube",
+		"usamplerCube",
+		"textureSize",
+		NULL
+	};
+
+	static const char* s_textureArray[] =
+	{
+		"sampler2DArray",
+		"texture2DArray",
+		"texture2DArrayLod",
+		"shadow2DArray",
+		NULL
+	};
+
+	static const char* s_ARB_texture_multisample[] =
+	{
+		"sampler2DMS",
+		"isampler2DMS",
+		"usampler2DMS",
+		NULL
+	};
+
+	static const char* s_texelFetch[] =
+	{
+		"texelFetch",
+		"texelFetchOffset",
+		NULL
+	};
+
+	static const char* s_bitsToEncoders[] =
+	{
+		"floatBitsToUint",
+		"floatBitsToInt",
+		"intBitsToFloat",
+		"uintBitsToFloat",
+		NULL
+	};
+
+	static const char* s_integerVecs[] =
+	{
+		"ivec2",
+		"uvec2",
+		"ivec3",
+		"uvec3",
+		"ivec4",
+		"uvec4",
+		NULL
+	};
+
+	const char* s_shaderc_uniformTypeName[] =
+	{
+		"int",  "int",
+		NULL,   NULL,
+		"vec4", "float4",
+		"mat3", "float3x3",
+		"mat4", "float4x4",
+	};
+	static_assert(BX_COUNTOF(s_shaderc_uniformTypeName) == UniformType::Count*2);
+
+	static const char* s_allowedVertexShaderInputs[] =
+	{
+		"a_position",
+		"a_normal",
+		"a_tangent",
+		"a_bitangent",
+		"a_color0",
+		"a_color1",
+		"a_color2",
+		"a_color3",
+		"a_indices",
+		"a_weight",
+		"a_texcoord0",
+		"a_texcoord1",
+		"a_texcoord2",
+		"a_texcoord3",
+		"a_texcoord4",
+		"a_texcoord5",
+		"a_texcoord6",
+		"a_texcoord7",
+		"i_data0",
+		"i_data1",
+		"i_data2",
+		"i_data3",
+		"i_data4",
+		NULL
+	};
+#ifndef BRTSHADERC_LIBRARY
+	void fatal(const char* _filePath, uint16_t _line, Fatal::Enum _code, const char* _format, ...)
+	{
+		BX_UNUSED(_filePath, _line, _code);
+
+		va_list argList;
+		va_start(argList, _format);
+
+		bx::vprintf(_format, argList);
+
+		va_end(argList);
+
+		abort();
+	}
+
+	void trace(const char* _filePath, uint16_t _line, const char* _format, ...)
+	{
+		BX_UNUSED(_filePath, _line);
+
+		va_list argList;
+		va_start(argList, _format);
+
+		bx::vprintf(_format, argList);
+
+		va_end(argList);
+	}
+#endif // BRTSHADERC_LIBRARY
+	Options::Options()
+		: shaderType(' ')
+		, disasm(false)
+		, raw(false)
+		, preprocessOnly(false)
+		, depends(false)
+		, debugInformation(false)
+		, avoidFlowControl(false)
+		, noPreshader(false)
+		, partialPrecision(false)
+		, preferFlowControl(false)
+		, backwardsCompatibility(false)
+		, warningsAreErrors(false)
+		, keepIntermediate(false)
+		, optimize(false)
+		, optimizationLevel(3)
+	{
+	}
+
+	void Options::dump()
+	{
+		BX_TRACE("Options:\n"
+			"\t  shaderType: %c\n"
+			"\t  platform: %s\n"
+			"\t  profile: %s\n"
+			"\t  inputFile: %s\n"
+			"\t  outputFile: %s\n"
+			"\t  disasm: %s\n"
+			"\t  raw: %s\n"
+			"\t  preprocessOnly: %s\n"
+			"\t  depends: %s\n"
+			"\t  debugInformation: %s\n"
+			"\t  avoidFlowControl: %s\n"
+			"\t  noPreshader: %s\n"
+			"\t  partialPrecision: %s\n"
+			"\t  preferFlowControl: %s\n"
+			"\t  backwardsCompatibility: %s\n"
+			"\t  warningsAreErrors: %s\n"
+			"\t  keepIntermediate: %s\n"
+			"\t  optimize: %s\n"
+			"\t  optimizationLevel: %d\n"
+
+			, shaderType
+			, platform.c_str()
+			, profile.c_str()
+			, inputFilePath.c_str()
+			, outputFilePath.c_str()
+			, disasm ? "true" : "false"
+			, raw ? "true" : "false"
+			, preprocessOnly ? "true" : "false"
+			, depends ? "true" : "false"
+			, debugInformation ? "true" : "false"
+			, avoidFlowControl ? "true" : "false"
+			, noPreshader ? "true" : "false"
+			, partialPrecision ? "true" : "false"
+			, preferFlowControl ? "true" : "false"
+			, backwardsCompatibility ? "true" : "false"
+			, warningsAreErrors ? "true" : "false"
+			, keepIntermediate ? "true" : "false"
+			, optimize ? "true" : "false"
+			, optimizationLevel
+			);
+
+		for (size_t ii = 0; ii < includeDirs.size(); ++ii)
+		{
+			BX_TRACE("\t  include :%s\n", includeDirs[ii].c_str() );
+		}
+
+		for (size_t ii = 0; ii < defines.size(); ++ii)
+		{
+			BX_TRACE("\t  define :%s\n", defines[ii].c_str() );
+		}
+
+		for (size_t ii = 0; ii < dependencies.size(); ++ii)
+		{
+			BX_TRACE("\t  dependency :%s\n", dependencies[ii].c_str() );
+		}
+	}
+
+	const char* interpolationDx11(const char* _glsl)
+	{
+		if (0 == bx::strCmp(_glsl, "smooth") )
+		{
+			return "linear";
+		}
+		else if (0 == bx::strCmp(_glsl, "flat") )
+		{
+			return "nointerpolation";
+		}
+
+		return _glsl; // centroid, noperspective
+	}
+
+	const char* shaderc_getUniformTypeName(UniformType::Enum _enum)
+	{
+		uint32_t idx = _enum & ~(kUniformFragmentBit|kUniformSamplerBit);
+		if (idx < UniformType::Count)
+		{
+			return s_shaderc_uniformTypeName[idx];
+		}
+
+		return "Unknown uniform type?!";
+	}
+
+	UniformType::Enum shaderc_nameToUniformTypeEnum(const char* _name)
+	{
+		for (uint32_t ii = 0; ii < UniformType::Count*2; ++ii)
+		{
+			if (NULL != s_shaderc_uniformTypeName[ii]
+			&&  0 == bx::strCmp(_name, s_shaderc_uniformTypeName[ii]) )
+			{
+				return UniformType::Enum(ii/2);
+			}
+		}
+
+		return UniformType::Count;
+	}
+
+	int32_t writef(bx::WriterI* _writer, const char* _format, ...)
+	{
+		va_list argList;
+		va_start(argList, _format);
+
+		char temp[2048];
+
+		char* out = temp;
+		int32_t max = sizeof(temp);
+		int32_t len = bx::vsnprintf(out, max, _format, argList);
+		if (len > max)
+		{
+			out = (char*)BX_STACK_ALLOC(len);
+			len = bx::vsnprintf(out, len, _format, argList);
+		}
+
+		len = bx::write(_writer, out, len, bx::ErrorAssert{});
+
+		va_end(argList);
+
+		return len;
+	}
+
+	class Bin2cWriter : public bx::FileWriter
+	{
+	public:
+		Bin2cWriter(const bx::StringView& _name)
+			: m_name(_name)
+		{
+		}
+
+		virtual ~Bin2cWriter()
+		{
+		}
+
+		virtual void close() override
+		{
+			generate();
+			return bx::FileWriter::close();
+		}
+
+		virtual int32_t write(const void* _data, int32_t _size, bx::Error*) override
+		{
+			const char* data = (const char*)_data;
+			m_buffer.insert(m_buffer.end(), data, data+_size);
+			return _size;
+		}
+
+	private:
+		void generate()
+		{
+#define HEX_DUMP_WIDTH 16
+#define HEX_DUMP_SPACE_WIDTH 96
+#define HEX_DUMP_FORMAT "%-" BX_STRINGIZE(HEX_DUMP_SPACE_WIDTH) "." BX_STRINGIZE(HEX_DUMP_SPACE_WIDTH) "s"
+			const uint8_t* data = &m_buffer[0];
+			uint32_t size = (uint32_t)m_buffer.size();
+
+			outf("static const uint8_t %.*s[%d] =\n{\n", m_name.getLength(), m_name.getPtr(), size);
+
+			if (NULL != data)
+			{
+				char hex[HEX_DUMP_SPACE_WIDTH+1];
+				char ascii[HEX_DUMP_WIDTH+1];
+				uint32_t hexPos = 0;
+				uint32_t asciiPos = 0;
+				for (uint32_t ii = 0; ii < size; ++ii)
+				{
+					bx::snprintf(&hex[hexPos], sizeof(hex)-hexPos, "0x%02x, ", data[asciiPos]);
+					hexPos += 6;
+
+					ascii[asciiPos] = isprint(data[asciiPos]) && data[asciiPos] != '\\'  && data[asciiPos] != '\t' ? data[asciiPos] : '.';
+					asciiPos++;
+
+					if (HEX_DUMP_WIDTH == asciiPos)
+					{
+						ascii[asciiPos] = '\0';
+						outf("\t" HEX_DUMP_FORMAT "// %s\n", hex, ascii);
+						data += asciiPos;
+						hexPos = 0;
+						asciiPos = 0;
+					}
+				}
+
+				if (0 != asciiPos)
+				{
+					ascii[asciiPos] = '\0';
+					outf("\t" HEX_DUMP_FORMAT "// %s\n", hex, ascii);
+				}
+			}
+
+			outf("};\n");
+#undef HEX_DUMP_WIDTH
+#undef HEX_DUMP_SPACE_WIDTH
+#undef HEX_DUMP_FORMAT
+		}
+
+		int32_t outf(const char* _format, ...)
+		{
+			va_list argList;
+			va_start(argList, _format);
+
+			char temp[2048];
+			char* out = temp;
+			int32_t max = sizeof(temp);
+			int32_t len = bx::vsnprintf(out, max, _format, argList);
+			if (len > max)
+			{
+				out = (char*)BX_STACK_ALLOC(len);
+				len = bx::vsnprintf(out, len, _format, argList);
+			}
+
+			int32_t size = bx::FileWriter::write(out, len, bx::ErrorAssert{});
+
+			va_end(argList);
+
+			return size;
+		}
+
+		bx::StringView m_name;
+		typedef std::vector<uint8_t> Buffer;
+		Buffer m_buffer;
+	};
+
+	struct Varying
+	{
+		std::string m_precision;
+		std::string m_interpolation;
+		std::string m_name;
+		std::string m_type;
+		std::string m_init;
+		std::string m_semantics;
+	};
+
+	typedef std::unordered_map<std::string, Varying> VaryingMap;
+
+	class File
+	{
+	public:
+		File()
+			: m_data(NULL)
+			, m_size(0)
+		{
+		}
+
+		~File()
+		{
+			delete [] m_data;
+		}
+
+		void load(const bx::FilePath& _filePath)
+		{
+			bx::FileReader reader;
+			if (bx::open(&reader, _filePath) )
+			{
+				m_size = (uint32_t)bx::getSize(&reader);
+				m_data = new char[m_size+1];
+				m_size = (uint32_t)bx::read(&reader, m_data, m_size, bx::ErrorAssert{});
+				bx::close(&reader);
+
+				if (m_data[0] == '\xef'
+				&&  m_data[1] == '\xbb'
+				&&  m_data[2] == '\xbf')
+				{
+					bx::memMove(m_data, &m_data[3], m_size-3);
+					m_size -= 3;
+				}
+
+				m_data[m_size] = '\0';
+			}
+		}
+
+		const char* getData() const
+		{
+			return m_data;
+		}
+
+		uint32_t getSize() const
+		{
+			return m_size;
+		}
+
+	private:
+		char* m_data;
+		uint32_t m_size;
+	};
+
+	char* strInsert(char* _str, const char* _insert)
+	{
+		uint32_t len = bx::strLen(_insert);
+		bx::memMove(&_str[len], _str, bx::strLen(_str) );
+		bx::memCopy(_str, _insert, len);
+		return _str + len;
+	}
+
+	void strReplace(char* _str, const char* _find, const char* _replace)
+	{
+		const int32_t len = bx::strLen(_find);
+
+		char* replace = (char*)BX_STACK_ALLOC(len+1);
+		bx::strCopy(replace, len+1, _replace);
+		for (int32_t ii = bx::strLen(replace); ii < len; ++ii)
+		{
+			replace[ii] = ' ';
+		}
+		replace[len] = '\0';
+
+		BX_ASSERT(len >= bx::strLen(_replace), "");
+		for (bx::StringView ptr = bx::strFind(_str, _find)
+			; !ptr.isEmpty()
+			; ptr = bx::strFind(ptr.getPtr() + len, _find)
+			)
+		{
+			bx::memCopy(const_cast<char*>(ptr.getPtr() ), replace, len);
+		}
+	}
+
+	void strNormalizeEol(char* _str)
+	{
+		strReplace(_str, "\r\n", "\n");
+		strReplace(_str, "\r",   "\n");
+	}
+
+	void printCode(const char* _code, int32_t _line, int32_t _start, int32_t _end, int32_t _column)
+	{
+		bx::printf("Code:\n---\n");
+
+		bx::LineReader reader(_code);
+		for (int32_t line = 1; !reader.isDone() && line < _end; ++line)
+		{
+			bx::StringView strLine = reader.next();
+
+			if (line >= _start)
+			{
+				if (_line == line)
+				{
+					bx::printf("\n");
+					bx::printf(">>> %3d: %.*s\n", line, strLine.getLength(), strLine.getPtr() );
+					if (-1 != _column)
+					{
+						bx::printf(">>> %3d: %*s\n", _column, _column, "^");
+					}
+					bx::printf("\n");
+				}
+				else
+				{
+					bx::printf("    %3d: %.*s\n", line, strLine.getLength(), strLine.getPtr() );
+				}
+			}
+		}
+
+		bx::printf("---\n");
+	}
+
+	void writeFile(const char* _filePath, const void* _data, int32_t _size)
+	{
+		bx::FileWriter out;
+		if (bx::open(&out, _filePath) )
+		{
+			bx::write(&out, _data, _size, bx::ErrorAssert{});
+			bx::close(&out);
+		}
+	}
+
+	struct Preprocessor
+	{
+		Preprocessor(const char* _filePath, bool _essl, bx::WriterI* _messageWriter)
+			: m_tagptr(m_tags)
+			, m_scratchPos(0)
+			, m_fgetsPos(0)
+			, m_messageWriter(_messageWriter)
+		{
+			m_tagptr->tag = FPPTAG_USERDATA;
+			m_tagptr->data = this;
+			m_tagptr++;
+
+			m_tagptr->tag = FPPTAG_DEPENDS;
+			m_tagptr->data = (void*)fppDepends;
+			m_tagptr++;
+
+			m_tagptr->tag = FPPTAG_INPUT;
+			m_tagptr->data = (void*)fppInput;
+			m_tagptr++;
+
+			m_tagptr->tag = FPPTAG_OUTPUT;
+			m_tagptr->data = (void*)fppOutput;
+			m_tagptr++;
+
+			m_tagptr->tag = FPPTAG_ERROR;
+			m_tagptr->data = (void*)fppError;
+			m_tagptr++;
+
+			m_tagptr->tag = FPPTAG_SHOWVERSION;
+			m_tagptr->data = (void*)0;
+			m_tagptr++;
+
+			m_tagptr->tag = FPPTAG_LINE;
+			m_tagptr->data = (void*)0;
+			m_tagptr++;
+
+			m_tagptr->tag = FPPTAG_INPUT_NAME;
+			m_tagptr->data = scratch(_filePath);
+			m_tagptr++;
+
+			if (!_essl)
+			{
+				m_default = "#define lowp\n#define mediump\n#define highp\n";
+			}
+		}
+
+		void setDefine(const char* _define)
+		{
+			m_tagptr->tag = FPPTAG_DEFINE;
+			m_tagptr->data = scratch(_define);
+			m_tagptr++;
+		}
+
+		void setDefaultDefine(const char* _name)
+		{
+			char temp[1024];
+			bx::snprintf(temp, BX_COUNTOF(temp)
+				, "#ifndef %s\n"
+				  "#	define %s 0\n"
+				  "#endif // %s\n"
+				  "\n"
+				, _name
+				, _name
+				, _name
+				);
+
+			m_default += temp;
+		}
+
+		void writef(const char* _format, ...)
+		{
+			va_list argList;
+			va_start(argList, _format);
+			bx::stringPrintfVargs(m_default, _format, argList);
+			va_end(argList);
+		}
+
+		void addInclude(const char* _includeDir)
+		{
+			char* start = scratch(_includeDir);
+
+			for (bx::StringView split = bx::strFind(start, ';')
+				; !split.isEmpty()
+				; split = bx::strFind(start, ';')
+				)
+			{
+				*const_cast<char*>(split.getPtr() ) = '\0';
+				m_tagptr->tag = FPPTAG_INCLUDE_DIR;
+				m_tagptr->data = start;
+				m_tagptr++;
+				start = const_cast<char*>(split.getPtr() ) + 1;
+			}
+
+			m_tagptr->tag = FPPTAG_INCLUDE_DIR;
+			m_tagptr->data = start;
+			m_tagptr++;
+		}
+
+		void addDependency(const char* _fileName)
+		{
+			m_depends += " \\\n ";
+			m_depends += _fileName;
+		}
+
+		bool run(const char* _input)
+		{
+			m_fgetsPos = 0;
+
+			m_preprocessed.clear();
+			m_input = m_default;
+			m_input += "\n\n";
+
+			int32_t len = bx::strLen(_input)+1;
+			char* temp = new char[len];
+			bx::StringView normalized = bx::normalizeEolLf(temp, len, _input);
+			std::string str;
+			str.assign(normalized.getPtr(), normalized.getTerm() );
+			m_input += str;
+			delete [] temp;
+
+			fppTag* tagptr = m_tagptr;
+
+			tagptr->tag = FPPTAG_END;
+			tagptr->data = 0;
+			tagptr++;
+
+			int result = fppPreProcess(m_tags);
+
+			return 0 == result;
+		}
+
+		char* fgets(char* _buffer, int _size)
+		{
+			int ii = 0;
+			for (char ch = m_input[m_fgetsPos]; m_fgetsPos < m_input.size() && ii < _size-1; ch = m_input[++m_fgetsPos])
+			{
+				_buffer[ii++] = ch;
+
+				if (ch == '\n' || ii == _size)
+				{
+					_buffer[ii] = '\0';
+					m_fgetsPos++;
+					return _buffer;
+				}
+			}
+
+			return NULL;
+		}
+
+		static void fppDepends(char* _fileName, void* _userData)
+		{
+			Preprocessor* thisClass = (Preprocessor*)_userData;
+			thisClass->addDependency(_fileName);
+		}
+
+		static char* fppInput(char* _buffer, int _size, void* _userData)
+		{
+			Preprocessor* thisClass = (Preprocessor*)_userData;
+			return thisClass->fgets(_buffer, _size);
+		}
+
+		static void fppOutput(int _ch, void* _userData)
+		{
+			Preprocessor* thisClass = (Preprocessor*)_userData;
+			thisClass->m_preprocessed += char(_ch);
+		}
+
+		static void fppError(void* _userData, char* _format, va_list _vargs)
+		{
+			bx::ErrorAssert err;
+			Preprocessor* thisClass = (Preprocessor*)_userData;
+			bx::write(thisClass->m_messageWriter, _format, _vargs, &err);
+		}
+
+		char* scratch(const char* _str)
+		{
+			char* result = &m_scratch[m_scratchPos];
+			bx::strCopy(result, uint32_t(sizeof(m_scratch)-m_scratchPos), _str);
+			m_scratchPos += (uint32_t)bx::strLen(_str)+1;
+
+			return result;
+		}
+
+		fppTag m_tags[MAX_TAGS];
+		fppTag* m_tagptr;
+
+		std::string m_depends;
+		std::string m_default;
+		std::string m_input;
+		std::string m_preprocessed;
+		char m_scratch[16<<10];
+		uint32_t m_scratchPos;
+		uint32_t m_fgetsPos;
+		bx::WriterI* m_messageWriter;
+	};
+
+	typedef std::vector<std::string> InOut;
+
+	uint32_t parseInOut(InOut& _inout, const bx::StringView& _str)
+	{
+		uint32_t hash = 0;
+		bx::StringView str = bx::strLTrimSpace(_str);
+
+		if (!str.isEmpty() )
+		{
+			bx::StringView delim;
+			do
+			{
+				delim = bx::strFind(str, ',');
+				if (delim.isEmpty() )
+				{
+					delim = bx::strFind(str, ' ');
+				}
+
+				const bx::StringView token(bx::strRTrim(bx::StringView(str.getPtr(), delim.getPtr() ), " ") );
+
+				if (!token.isEmpty() )
+				{
+					_inout.push_back(std::string(token.getPtr(), token.getTerm() ) );
+					str = bx::strLTrimSpace(bx::StringView(delim.getPtr() + 1, str.getTerm() ) );
+				}
+			}
+			while (!delim.isEmpty() );
+
+			std::sort(_inout.begin(), _inout.end() );
+
+			bx::HashMurmur2A murmur;
+			murmur.begin();
+			for (InOut::const_iterator it = _inout.begin(), itEnd = _inout.end(); it != itEnd; ++it)
+			{
+				murmur.add(it->c_str(), (uint32_t)it->size() );
+			}
+			hash = murmur.end();
+		}
+
+		return hash;
+	}
+
+	void addFragData(Preprocessor& _preprocessor, char* _data, uint32_t _idx, bool _comma)
+	{
+		char find[32];
+		bx::snprintf(find, sizeof(find), "gl_FragData[%d]", _idx);
+
+		char replace[32];
+		bx::snprintf(replace, sizeof(replace), "bgfx_FragData%d", _idx);
+
+		strReplace(_data, find, replace);
+
+		_preprocessor.writef(
+			" \\\n\t%sout vec4 bgfx_FragData%d : SV_TARGET%d"
+			, _comma ? ", " : "  "
+			, _idx
+			, _idx
+			);
+	}
+
+	void voidFragData(char* _data, uint32_t _idx)
+	{
+		char find[32];
+		bx::snprintf(find, sizeof(find), "gl_FragData[%d]", _idx);
+
+		strReplace(_data, find, "bgfx_VoidFrag");
+	}
+
+	bx::StringView baseName(const bx::StringView& _filePath)
+	{
+		bx::FilePath fp(_filePath);
+		return bx::strFind(_filePath, fp.getBaseName() );
+	}
+
+	void help(const char* _error = NULL)
+	{
+		if (NULL != _error)
+		{
+			bx::printf("Error:\n%s\n\n", _error);
+		}
+
+		bx::printf(
+			  "shaderc, bgfx shader compiler tool, version %d.%d.%d.\n"
+			  "Copyright 2011-2025 Branimir Karadzic. All rights reserved.\n"
+			  "License: https://github.com/bkaradzic/bgfx/blob/master/LICENSE\n\n"
+			, BGFX_SHADERC_VERSION_MAJOR
+			, BGFX_SHADERC_VERSION_MINOR
+			, BGFX_API_VERSION
+			);
+
+		bx::printf(
+			  "Usage: shaderc -f <in> -o <out> --type <v/f/c> --platform <platform>\n"
+
+			  "\n"
+			  "Options:\n"
+			  "  -h, --help                    Display this help and exit.\n"
+			  "  -v, --version                 Output version information and exit.\n"
+			  "  -f <file path>                Input's file path.\n"
+			  "  -i <include path>             Include path. (for multiple paths use -i multiple times)\n"
+			  "  -o <file path>                Output's file path.\n"
+			  "      --stdout                  Output to console.\n"
+			  "      --bin2c [array name]      Generate C header file. If array name is not specified base file name will be used as name.\n"
+			  "      --depends                 Generate makefile style depends file.\n"
+			  "      --platform <platform>     Target platform.\n"
+			  "           android\n"
+			  "           asm.js\n"
+			  "           ios\n"
+			  "           linux\n"
+			  "           orbis\n"
+			  "           osx\n"
+			  "           windows\n"
+			  "      -p, --profile <profile>   Shader model. Defaults to GLSL.\n"
+			);
+
+		{
+			ShadingLang::Enum lang = ShadingLang::Count;
+			for (uint32_t ii = 0; ii < BX_COUNTOF(s_profiles); ++ii)
+			{
+				const Profile& profile = s_profiles[ii];
+				if (lang != profile.lang)
+				{
+					lang = profile.lang;
+					bx::printf("\n");
+					bx::printf("           %-20S %s\n", &profile.name, getName(profile.lang) );
+				}
+				else
+				{
+					bx::printf("           %S\n", &profile.name);
+				}
+
+			}
+		}
+
+		bx::printf(
+			  "      --preprocess              Only pre-process.\n"
+			  "      --define <defines>        Add defines to preprocessor. (Semicolon-separated)\n"
+			  "      --raw                     Do not process shader. No preprocessor, and no glsl-optimizer. (GLSL only)\n"
+			  "      --type <type>             Shader type. Can be 'vertex', 'fragment, or 'compute'.\n"
+			  "      --varyingdef <file path>  varying.def.sc's file path.\n"
+			  "      --verbose                 Be verbose.\n"
+
+			  "\n"
+			  "(Vulkan, DirectX and Metal):\n"
+
+			  "\n"
+			  "      --debug                   Debug information.\n"
+
+			  "\n"
+			  "(DirectX only):\n"
+
+			  "\n"
+			  "      --disasm                  Disassemble compiled shader.\n"
+			  "  -O <level>                    Set optimization level. Can be 0 to 3.\n"
+			  "      --Werror                  Treat warnings as errors.\n"
+
+			  "\n"
+			  "For additional information, see https://github.com/bkaradzic/bgfx\n"
+			);
+	}
+
+	bx::StringView nextWord(bx::StringView& _parse)
+	{
+		bx::StringView word = bx::strWord(bx::strLTrimSpace(_parse) );
+		_parse = bx::strLTrimSpace(bx::StringView(word.getTerm(), _parse.getTerm() ) );
+		return word;
+	}
+
+	bool compileShader(const char* _varying, const char* _comment, char* _shader, uint32_t _shaderLen, const Options& _options, bx::WriterI* _shaderWriter, bx::WriterI* _messageWriter)
+	{
+		bx::ErrorAssert messageErr;
+
+		uint32_t profileId = 0;
+
+		const bx::StringView profileOpt(_options.profile.c_str() );
+		if (!profileOpt.isEmpty() )
+		{
+			const uint32_t count = BX_COUNTOF(s_profiles);
+			for (profileId = 0; profileId < count; ++profileId)
+			{
+				if (0 == bx::strCmp(profileOpt, s_profiles[profileId].name) )
+				{
+					break;
+				}
+			}
+
+			if (profileId == count)
+			{
+				bx::write(_messageWriter, &messageErr, "Unknown profile: %S\n", &profileOpt);
+				return false;
+			}
+		}
+		else
+		{
+			bx::write(_messageWriter, &messageErr, "Shader profile must be specified.\n");
+			return false;
+		}
+
+		const Profile* profile = &s_profiles[profileId];
+
+		Preprocessor preprocessor(_options.inputFilePath.c_str(), profile->lang == ShadingLang::ESSL, _messageWriter);
+
+		for (size_t ii = 0; ii < _options.includeDirs.size(); ++ii)
+		{
+			preprocessor.addInclude(_options.includeDirs[ii].c_str() );
+		}
+
+		for (size_t ii = 0; ii < _options.defines.size(); ++ii)
+		{
+			preprocessor.setDefine(_options.defines[ii].c_str() );
+		}
+
+		for (size_t ii = 0; ii < _options.dependencies.size(); ++ii)
+		{
+			preprocessor.addDependency(_options.dependencies[ii].c_str() );
+		}
+
+		preprocessor.setDefaultDefine("BX_PLATFORM_ANDROID");
+		preprocessor.setDefaultDefine("BX_PLATFORM_EMSCRIPTEN");
+		preprocessor.setDefaultDefine("BX_PLATFORM_IOS");
+		preprocessor.setDefaultDefine("BX_PLATFORM_VISIONOS");
+		preprocessor.setDefaultDefine("BX_PLATFORM_LINUX");
+		preprocessor.setDefaultDefine("BX_PLATFORM_OSX");
+		preprocessor.setDefaultDefine("BX_PLATFORM_PS4");
+		preprocessor.setDefaultDefine("BX_PLATFORM_WINDOWS");
+		preprocessor.setDefaultDefine("BX_PLATFORM_XBOXONE");
+
+		preprocessor.setDefaultDefine("BGFX_SHADER_LANGUAGE_GLSL");
+		preprocessor.setDefaultDefine("BGFX_SHADER_LANGUAGE_HLSL");
+		preprocessor.setDefaultDefine("BGFX_SHADER_LANGUAGE_METAL");
+		preprocessor.setDefaultDefine("BGFX_SHADER_LANGUAGE_PSSL");
+		preprocessor.setDefaultDefine("BGFX_SHADER_LANGUAGE_SPIRV");
+
+		preprocessor.setDefaultDefine("BGFX_SHADER_TYPE_COMPUTE");
+		preprocessor.setDefaultDefine("BGFX_SHADER_TYPE_FRAGMENT");
+		preprocessor.setDefaultDefine("BGFX_SHADER_TYPE_VERTEX");
+
+		char glslDefine[128];
+		if (profile->lang == ShadingLang::GLSL
+		||  profile->lang == ShadingLang::ESSL)
+		{
+			bx::snprintf(glslDefine, BX_COUNTOF(glslDefine)
+				, "BGFX_SHADER_LANGUAGE_GLSL=%d"
+				, profile->id
+				);
+		}
+
+		char hlslDefine[128];
+		if (profile->lang == ShadingLang::HLSL)
+		{
+			bx::snprintf(hlslDefine, BX_COUNTOF(hlslDefine)
+				, "BGFX_SHADER_LANGUAGE_HLSL=%d"
+				, profile->id);
+		}
+
+		const char* platform = _options.platform.c_str();
+
+		if (0 == bx::strCmpI(platform, "android") )
+		{
+			preprocessor.setDefine("BX_PLATFORM_ANDROID=1");
+			if (profile->lang == ShadingLang::SpirV)
+			{
+				preprocessor.setDefine("BGFX_SHADER_LANGUAGE_SPIRV=1");
+			}
+			else
+			{
+				preprocessor.setDefine(glslDefine);
+			}
+		}
+		else if (0 == bx::strCmpI(platform, "asm.js") )
+		{
+			preprocessor.setDefine("BX_PLATFORM_EMSCRIPTEN=1");
+			preprocessor.setDefine(glslDefine);
+		}
+		else if (0 == bx::strCmpI(platform, "linux") )
+		{
+			preprocessor.setDefine("BX_PLATFORM_LINUX=1");
+			if (profile->lang == ShadingLang::SpirV)
+			{
+				preprocessor.setDefine("BGFX_SHADER_LANGUAGE_SPIRV=1");
+			}
+			else
+			{
+				preprocessor.setDefine(glslDefine);
+			}
+		}
+		else if (
+			0 == bx::strCmpI(platform, "ios") ||
+			0 == bx::strCmpI(platform, "osx") ||
+			0 == bx::strCmpI(platform, "visionos")
+		)
+		{
+			if (0 == bx::strCmpI(platform, "osx"))
+			{
+				preprocessor.setDefine("BX_PLATFORM_OSX=1");
+			}
+			else if (0 == bx::strCmpI(platform, "visionos")) {
+				preprocessor.setDefine("BX_PLATFORM_VISIONOS=1");
+			}
+			else
+			{
+				preprocessor.setDefine("BX_PLATFORM_IOS=1");
+			}
+
+			if (profile->lang != ShadingLang::Metal)
+			{
+				preprocessor.setDefine(glslDefine);
+			}
+			char temp[32];
+			bx::snprintf(
+				temp
+				, sizeof(temp)
+				, "BGFX_SHADER_LANGUAGE_METAL=%d"
+				, (profile->lang == ShadingLang::Metal) ? profile->id : 0
+			);
+			preprocessor.setDefine(temp);
+		}
+		else if (0 == bx::strCmpI(platform, "windows") )
+		{
+			preprocessor.setDefine("BX_PLATFORM_WINDOWS=1");
+			if (profile->lang == ShadingLang::HLSL)
+			{
+				preprocessor.setDefine(hlslDefine);
+			}
+			else if (profile->lang == ShadingLang::GLSL
+			     ||  profile->lang == ShadingLang::ESSL)
+			{
+				preprocessor.setDefine(glslDefine);
+			}
+			else if (profile->lang == ShadingLang::SpirV)
+			{
+				preprocessor.setDefine("BGFX_SHADER_LANGUAGE_SPIRV=1");
+			}
+		}
+		else if (0 == bx::strCmpI(platform, "orbis") )
+		{
+			preprocessor.setDefine("BX_PLATFORM_PS4=1");
+			preprocessor.setDefine("BGFX_SHADER_LANGUAGE_PSSL=1");
+			preprocessor.setDefine("lit=lit_reserved");
+		}
+		else
+		{
+			if (profile->lang == ShadingLang::HLSL)
+			{
+				preprocessor.setDefine(hlslDefine);
+			}
+			else if (profile->lang == ShadingLang::GLSL
+			     ||  profile->lang == ShadingLang::ESSL)
+			{
+				preprocessor.setDefine(glslDefine);
+			}
+			else if (profile->lang == ShadingLang::SpirV)
+			{
+				preprocessor.setDefine("BGFX_SHADER_LANGUAGE_SPIRV=1");
+			}
+		}
+
+		preprocessor.setDefine("M_PI=3.1415926535897932384626433832795");
+
+		switch (_options.shaderType)
+		{
+		case 'c':
+			preprocessor.setDefine("BGFX_SHADER_TYPE_COMPUTE=1");
+			break;
+
+		case 'f':
+			preprocessor.setDefine("BGFX_SHADER_TYPE_FRAGMENT=1");
+			break;
+
+		case 'v':
+			preprocessor.setDefine("BGFX_SHADER_TYPE_VERTEX=1");
+			break;
+
+		default:
+			bx::write(_messageWriter, &messageErr, "Unknown type: %c?!", _options.shaderType);
+			return false;
+		}
+
+		bool compiled = false;
+
+		VaryingMap varyingMap;
+		bx::StringView parse(_varying);
+		bx::StringView term(parse);
+
+		bool usesInterpolationQualifiers = false;
+
+		while (!parse.isEmpty() )
+		{
+			parse = bx::strLTrimSpace(parse);
+			bx::StringView eol = bx::strFind(parse, ';');
+			if (eol.isEmpty() )
+			{
+				eol = bx::strFindEol(parse);
+			}
+
+			if (!eol.isEmpty() )
+			{
+				eol.set(eol.getPtr() + 1, parse.getTerm() );
+
+				bx::StringView precision;
+				bx::StringView interpolation;
+				bx::StringView typen = nextWord(parse);
+
+				if (0 == bx::strCmp(typen, "lowp", 4)
+				||  0 == bx::strCmp(typen, "mediump", 7)
+				||  0 == bx::strCmp(typen, "highp", 5) )
+				{
+					precision = typen;
+					typen = nextWord(parse);
+				}
+
+				if (0 == bx::strCmp(typen, "flat", 4)
+				||  0 == bx::strCmp(typen, "smooth", 6)
+				||  0 == bx::strCmp(typen, "noperspective", 13)
+				||  0 == bx::strCmp(typen, "centroid", 8) )
+				{
+					if ('f' == _options.shaderType
+					||   profile->lang == ShadingLang::GLSL
+					||   profile->lang == ShadingLang::ESSL)
+					{
+						interpolation = typen;
+						usesInterpolationQualifiers = true;
+					}
+
+					typen = nextWord(parse);
+				}
+
+				bx::StringView name   = nextWord(parse);
+				bx::StringView column = bx::strSubstr(parse, 0, 1);
+				bx::StringView semantics;
+				if (0 == bx::strCmp(column, ":", 1) )
+				{
+					parse = bx::strLTrimSpace(bx::StringView(parse.getPtr() + 1, parse.getTerm() ) );
+					semantics = nextWord(parse);
+				}
+
+				bx::StringView assign = bx::strSubstr(parse, 0, 1);
+				bx::StringView init;
+				if (0 == bx::strCmp(assign, "=", 1) )
+				{
+					parse = bx::strLTrimSpace(bx::StringView(parse.getPtr() + 1, parse.getTerm() ) );
+					init.set(parse.getPtr(), eol.getPtr() );
+				}
+
+				if (!typen.isEmpty()
+				&&  !name.isEmpty()
+				&&  !semantics.isEmpty() )
+				{
+					Varying var;
+					if (!precision.isEmpty() )
+					{
+						var.m_precision.assign(precision.getPtr(), precision.getTerm() );
+					}
+
+					if (!interpolation.isEmpty() )
+					{
+						var.m_interpolation.assign(interpolation.getPtr(), interpolation.getTerm() );
+					}
+
+					var.m_type.assign(typen.getPtr(), typen.getTerm() );
+					var.m_name.assign(name.getPtr(), name.getTerm() );
+					var.m_semantics.assign(semantics.getPtr(), semantics.getTerm() );
+
+					if (profile->lang == ShadingLang::HLSL
+					&&  profile->id < 400
+					&&  var.m_semantics == "BITANGENT")
+					{
+						var.m_semantics = "BINORMAL";
+					}
+
+					if (!init.isEmpty() )
+					{
+						var.m_init.assign(init.getPtr(), init.getTerm() );
+					}
+
+					varyingMap.insert(std::make_pair(var.m_name, var) );
+				}
+
+				parse = bx::strLTrimSpace(bx::strFindNl(bx::StringView(eol.getPtr(), term.getTerm() ) ) );
+			}
+		}
+
+		bool raw = _options.raw;
+
+		InOut shaderInputs;
+		InOut shaderOutputs;
+		uint32_t inputHash = 0;
+		uint32_t outputHash = 0;
+		bx::ErrorAssert err;
+
+		char* data;
+		char* input;
+		{
+			data = _shader;
+			uint32_t size = _shaderLen;
+
+			const size_t padding = 16384;
+
+			if (!raw)
+			{
+				// To avoid commented code being recognized as used feature,
+				// first preprocess pass is used to strip all comments before
+				// substituting code.
+				bool ok = preprocessor.run(data);
+				delete [] data;
+
+				if (!ok)
+				{
+					return false;
+				}
+
+				size = (uint32_t)preprocessor.m_preprocessed.size();
+				data = new char[size+padding+1];
+				bx::memCopy(data, preprocessor.m_preprocessed.c_str(), size);
+				bx::memSet(&data[size], 0, padding+1);
+			}
+
+			strNormalizeEol(data);
+
+			input = const_cast<char*>(bx::strLTrimSpace(data).getPtr() );
+			while (input[0] == '$')
+			{
+				bx::StringView str = bx::strLTrimSpace(input+1);
+				bx::StringView eol = bx::strFindEol(str);
+				bx::StringView nl  = bx::strFindNl(eol);
+				input = const_cast<char*>(nl.getPtr() );
+
+				if (0 == bx::strCmp(str, "input", 5) )
+				{
+					str = bx::StringView(str.getPtr() + 5, str.getTerm() );
+					bx::StringView comment = bx::strFind(str, "//");
+					eol = !comment.isEmpty() && comment.getPtr() < eol.getPtr() ? comment.getPtr() : eol;
+					inputHash = parseInOut(shaderInputs, bx::StringView(str.getPtr(), eol.getPtr() ) );
+				}
+				else if (0 == bx::strCmp(str, "output", 6) )
+				{
+					str = bx::StringView(str.getPtr() + 6, str.getTerm() );
+					bx::StringView comment = bx::strFind(str, "//");
+					eol = !comment.isEmpty() && comment.getPtr() < eol.getPtr() ? comment.getPtr() : eol;
+					outputHash = parseInOut(shaderOutputs, bx::StringView(str.getPtr(), eol.getPtr() ) );
+				}
+				else if (0 == bx::strCmp(str, "raw", 3) )
+				{
+					raw = true;
+					str = bx::StringView(str.getPtr() + 3, str.getTerm() );
+				}
+
+				input = const_cast<char*>(bx::strLTrimSpace(input).getPtr() );
+			}
+		}
+
+		bool invalidShaderAttribute = false;
+		if ('v' == _options.shaderType)
+		{
+			for (InOut::const_iterator it = shaderInputs.begin(), itEnd = shaderInputs.end(); it != itEnd; ++it)
+			{
+				if (bx::findIdentifierMatch(it->c_str(), s_allowedVertexShaderInputs).isEmpty() )
+				{
+					invalidShaderAttribute = true;
+					bx::write(_messageWriter, &messageErr,
+						  "Invalid vertex shader input attribute '%s'.\n"
+						  "\n"
+						  "Valid input attributes:\n"
+						  "  a_position, a_normal, a_tangent, a_bitangent, a_color0, a_color1, a_color2, a_color3, a_indices, a_weight,\n"
+						  "  a_texcoord0, a_texcoord1, a_texcoord2, a_texcoord3, a_texcoord4, a_texcoord5, a_texcoord6, a_texcoord7,\n"
+						  "  i_data0, i_data1, i_data2, i_data3, i_data4.\n"
+						  "\n"
+						, it->c_str() );
+					break;
+				}
+			}
+		}
+
+		if (invalidShaderAttribute)
+		{
+		}
+		else if (raw)
+		{
+			if ('f' == _options.shaderType)
+			{
+				bx::write(_shaderWriter, BGFX_CHUNK_MAGIC_FSH, &err);
+			}
+			else if ('v' == _options.shaderType)
+			{
+				bx::write(_shaderWriter, BGFX_CHUNK_MAGIC_VSH, &err);
+			}
+			else
+			{
+				bx::write(_shaderWriter, BGFX_CHUNK_MAGIC_CSH, &err);
+			}
+
+			bx::write(_shaderWriter, inputHash, &err);
+			bx::write(_shaderWriter, outputHash, &err);
+		}
+
+		if (raw)
+		{
+			if (profile->lang == ShadingLang::GLSL)
+			{
+				bx::write(_shaderWriter, uint16_t(0), &err);
+
+				const uint32_t shaderSize = (uint32_t)bx::strLen(input);
+				bx::write(_shaderWriter, shaderSize, &err);
+				bx::write(_shaderWriter, input, shaderSize, &err);
+				bx::write(_shaderWriter, uint8_t(0), &err);
+
+				compiled = true;
+			}
+			else if (profile->lang == ShadingLang::Metal)
+			{
+				compiled = compileMetalShader(_options, profile->id, input, _shaderWriter, _messageWriter);
+			}
+			else if (profile->lang == ShadingLang::SpirV)
+			{
+				compiled = compileSPIRVShader(_options, profile->id, input, _shaderWriter, _messageWriter);
+			}
+			else if (profile->lang == ShadingLang::PSSL)
+			{
+				compiled = compilePSSLShader(_options, 0, input, _shaderWriter, _messageWriter);
+			}
+			else
+			{
+				compiled = compileHLSLShader(_options, profile->id, input, _shaderWriter, _messageWriter);
+			}
+		}
+		else if ('c' == _options.shaderType) // Compute
+		{
+			bx::StringView entry = bx::strFind(input, "void main()");
+			if (entry.isEmpty() )
+			{
+				bx::write(_messageWriter, &messageErr, "Shader entry point 'void main()' is not found.\n");
+			}
+			else
+			{
+				if (profile->lang == ShadingLang::GLSL
+				||  profile->lang == ShadingLang::ESSL)
+				{
+				}
+				else
+				{
+					if (profile->lang == ShadingLang::PSSL)
+					{
+						preprocessor.writef(getPsslPreamble() );
+					}
+
+					preprocessor.writef(
+						"#define lowp\n"
+						"#define mediump\n"
+						"#define highp\n"
+						"#define ivec2 int2\n"
+						"#define ivec3 int3\n"
+						"#define ivec4 int4\n"
+						"#define uvec2 uint2\n"
+						"#define uvec3 uint3\n"
+						"#define uvec4 uint4\n"
+						"#define vec2 float2\n"
+						"#define vec3 float3\n"
+						"#define vec4 float4\n"
+						"#define mat2 float2x2\n"
+						"#define mat3 float3x3\n"
+						"#define mat4 float4x4\n"
+						);
+
+					*const_cast<char*>(entry.getPtr() + 4) = '_';
+
+					preprocessor.writef("#define void_main()");
+					preprocessor.writef(" \\\n\tvoid main(");
+
+					uint32_t arg = 0;
+
+					const bool hasLocalInvocationID    = !bx::strFind(input, "gl_LocalInvocationID").isEmpty();
+					const bool hasLocalInvocationIndex = !bx::strFind(input, "gl_LocalInvocationIndex").isEmpty();
+					const bool hasGlobalInvocationID   = !bx::strFind(input, "gl_GlobalInvocationID").isEmpty();
+					const bool hasWorkGroupID          = !bx::strFind(input, "gl_WorkGroupID").isEmpty();
+
+					if (hasLocalInvocationID)
+					{
+						preprocessor.writef(
+							" \\\n\t%sint3 gl_LocalInvocationID : SV_GroupThreadID"
+							, arg++ > 0 ? ", " : "  "
+							);
+					}
+
+					if (hasLocalInvocationIndex)
+					{
+						preprocessor.writef(
+							" \\\n\t%sint gl_LocalInvocationIndex : SV_GroupIndex"
+							, arg++ > 0 ? ", " : "  "
+							);
+					}
+
+					if (hasGlobalInvocationID)
+					{
+						preprocessor.writef(
+							" \\\n\t%sint3 gl_GlobalInvocationID : SV_DispatchThreadID"
+							, arg++ > 0 ? ", " : "  "
+							);
+					}
+
+					if (hasWorkGroupID)
+					{
+						preprocessor.writef(
+							" \\\n\t%sint3 gl_WorkGroupID : SV_GroupID"
+							, arg++ > 0 ? ", " : "  "
+							);
+					}
+
+					preprocessor.writef(
+						" \\\n\t)\n"
+						);
+				}
+
+				if (preprocessor.run(input) )
+				{
+					if (_options.preprocessOnly)
+					{
+						bx::write(
+							_shaderWriter
+							, preprocessor.m_preprocessed.c_str()
+							, (int32_t)preprocessor.m_preprocessed.size()
+							, &err
+							);
+
+						return true;
+					}
+
+					{
+						std::string code;
+
+						bx::write(_shaderWriter, BGFX_CHUNK_MAGIC_CSH, &err);
+						bx::write(_shaderWriter, uint32_t(0), &err);
+						bx::write(_shaderWriter, outputHash, &err);
+
+						if (profile->lang == ShadingLang::GLSL
+						||  profile->lang == ShadingLang::ESSL)
+						{
+							if (profile->lang == ShadingLang::ESSL)
+							{
+								bx::stringPrintf(code, "#version 310 es\n");
+							}
+							else
+							{
+								bx::stringPrintf(
+									  code
+									, "#version %d\n"
+									, (profile->lang != ShadingLang::GLSL) ? 430 : profile->id
+									);
+							}
+
+							code += preprocessor.m_preprocessed;
+
+							bx::write(_shaderWriter, uint16_t(0), &err);
+
+							uint32_t shaderSize = (uint32_t)code.size();
+							bx::write(_shaderWriter, shaderSize, &err);
+							bx::write(_shaderWriter, code.c_str(), shaderSize, &err);
+							bx::write(_shaderWriter, uint8_t(0), &err);
+
+							compiled = true;
+						}
+						else
+						{
+							code += _comment;
+							code += preprocessor.m_preprocessed;
+
+							if (profile->lang == ShadingLang::Metal)
+							{
+								compiled = compileMetalShader(_options, profile->id, code, _shaderWriter, _messageWriter);
+							}
+							else if (profile->lang == ShadingLang::SpirV)
+							{
+								compiled = compileSPIRVShader(_options, profile->id, code, _shaderWriter, _messageWriter);
+							}
+							else if (profile->lang == ShadingLang::PSSL)
+							{
+								compiled = compilePSSLShader(_options, 0, code, _shaderWriter, _messageWriter);
+							}
+							else
+							{
+								compiled = compileHLSLShader(_options, profile->id, code, _shaderWriter, _messageWriter);
+							}
+						}
+					}
+
+					if (compiled)
+					{
+						if (_options.depends)
+						{
+							std::string ofp = _options.outputFilePath;
+							ofp += ".d";
+							bx::FileWriter writer;
+							if (bx::open(&writer, ofp.c_str() ) )
+							{
+								writef(&writer, "%s : %s\n", _options.outputFilePath.c_str(), preprocessor.m_depends.c_str() );
+								bx::close(&writer);
+							}
+						}
+					}
+				}
+			}
+		}
+		else // Vertex/Fragment
+		{
+			bx::StringView shader(input);
+			bx::StringView entry = bx::strFind(shader, "void main()");
+			if (entry.isEmpty() )
+			{
+				bx::write(_messageWriter, &messageErr, "Shader entry point 'void main()' is not found.\n");
+			}
+			else
+			{
+				if (profile->lang == ShadingLang::GLSL
+				||  profile->lang == ShadingLang::ESSL)
+				{
+					if (profile->lang != ShadingLang::ESSL)
+					{
+						// bgfx shadow2D/Proj behave like EXT_shadow_samplers
+						// not as GLSL language 1.2 specs shadow2D/Proj.
+						preprocessor.writef(
+							"#define shadow2D(_sampler, _coord) bgfxShadow2D(_sampler, _coord).x\n"
+							"#define shadow2DProj(_sampler, _coord) bgfxShadow2DProj(_sampler, _coord).x\n"
+							);
+					}
+
+					// gl_FragColor and gl_FragData are deprecated for essl > 300
+					if (profile->lang == ShadingLang::ESSL
+					&&  profile->id >= 300)
+					{
+						const bool hasFragColor   = !bx::strFind(input, "gl_FragColor").isEmpty();
+						bool hasFragData[8] = {};
+						uint32_t numFragData = 0;
+						for (uint32_t ii = 0; ii < BX_COUNTOF(hasFragData); ++ii)
+						{
+							char temp[32];
+							bx::snprintf(temp, BX_COUNTOF(temp), "gl_FragData[%d]", ii);
+							hasFragData[ii] = !bx::strFind(input, temp).isEmpty();
+							numFragData += hasFragData[ii];
+						}
+						if (hasFragColor)
+						{
+							preprocessor.writef("#define gl_FragColor bgfx_FragColor\n");
+							preprocessor.writef("out mediump vec4 bgfx_FragColor;\n");
+						}
+						else if (numFragData)
+						{
+							preprocessor.writef("#define gl_FragData bgfx_FragData\n");
+							preprocessor.writef("out mediump vec4 bgfx_FragData[gl_MaxDrawBuffers];\n");
+						}
+					}
+
+					for (InOut::const_iterator it = shaderInputs.begin(), itEnd = shaderInputs.end(); it != itEnd; ++it)
+					{
+						VaryingMap::const_iterator varyingIt = varyingMap.find(*it);
+						if (varyingIt != varyingMap.end() )
+						{
+							const Varying& var = varyingIt->second;
+							const char* name = var.m_name.c_str();
+
+							if (0 == bx::strCmp(name, "a_", 2)
+							||  0 == bx::strCmp(name, "i_", 2) )
+							{
+								preprocessor.writef(
+									  "attribute %s %s %s %s;\n"
+									, var.m_precision.c_str()
+									, var.m_interpolation.c_str()
+									, var.m_type.c_str()
+									, name
+									);
+							}
+							else
+							{
+								preprocessor.writef(
+									  "%s varying %s %s %s;\n"
+									, var.m_interpolation.c_str()
+									, var.m_precision.c_str()
+									, var.m_type.c_str()
+									, name
+									);
+							}
+						}
+					}
+
+					for (InOut::const_iterator it = shaderOutputs.begin(), itEnd = shaderOutputs.end(); it != itEnd; ++it)
+					{
+						VaryingMap::const_iterator varyingIt = varyingMap.find(*it);
+						if (varyingIt != varyingMap.end() )
+						{
+							const Varying& var = varyingIt->second;
+							preprocessor.writef("%s varying %s %s;\n"
+								, var.m_interpolation.c_str()
+								, var.m_type.c_str()
+								, var.m_name.c_str()
+								);
+						}
+					}
+				}
+				else
+				{
+					if (profile->lang == ShadingLang::PSSL)
+					{
+						preprocessor.writef(getPsslPreamble() );
+					}
+
+					preprocessor.writef(
+						"#define lowp\n"
+						"#define mediump\n"
+						"#define highp\n"
+						"#define ivec2 int2\n"
+						"#define ivec3 int3\n"
+						"#define ivec4 int4\n"
+						"#define uvec2 uint2\n"
+						"#define uvec3 uint3\n"
+						"#define uvec4 uint4\n"
+						"#define vec2 float2\n"
+						"#define vec3 float3\n"
+						"#define vec4 float4\n"
+						"#define mat2 float2x2\n"
+						"#define mat3 float3x3\n"
+						"#define mat4 float4x4\n"
+						);
+
+					if (profile->lang == ShadingLang::HLSL
+					&&  profile->id < 400)
+					{
+						preprocessor.writef(
+							"#define centroid\n"
+							"#define flat\n"
+							"#define noperspective\n"
+							"#define smooth\n"
+							);
+					}
+
+					*const_cast<char*>(entry.getPtr() + 4) = '_';
+
+					if ('f' == _options.shaderType)
+					{
+						bx::StringView insert = bx::strFind(bx::StringView(entry.getPtr(), shader.getTerm() ), "{");
+						if (!insert.isEmpty() )
+						{
+							insert = strInsert(const_cast<char*>(insert.getPtr()+1), "\nvec4 bgfx_VoidFrag = vec4_splat(0.0);\n");
+						}
+
+						const bool hasFragColor   = !bx::strFind(input, "gl_FragColor").isEmpty();
+						const bool hasFragCoord   = !bx::strFind(input, "gl_FragCoord").isEmpty() || profile->id >= 400;
+						const bool hasFragDepth   = !bx::strFind(input, "gl_FragDepth").isEmpty();
+						const bool hasFrontFacing = !bx::strFind(input, "gl_FrontFacing").isEmpty();
+						const bool hasPrimitiveId = !bx::strFind(input, "gl_PrimitiveID").isEmpty() && BGFX_CAPS_PRIMITIVE_ID;
+
+						if (!hasPrimitiveId)
+						{
+							preprocessor.writef("#define gl_PrimitiveID 0\n");
+						}
+
+						bool hasFragData[8] = {};
+						uint32_t numFragData = 0;
+						for (uint32_t ii = 0; ii < BX_COUNTOF(hasFragData); ++ii)
+						{
+							char temp[32];
+							bx::snprintf(temp, BX_COUNTOF(temp), "gl_FragData[%d]", ii);
+							hasFragData[ii] = !bx::strFind(input, temp).isEmpty();
+							numFragData += hasFragData[ii];
+						}
+
+						if (0 == numFragData)
+						{
+							// GL errors when both gl_FragColor and gl_FragData is used.
+							// This will trigger the same error with HLSL compiler too.
+							preprocessor.writef("#define gl_FragColor bgfx_FragData0\n");
+
+							// If it has gl_FragData or gl_FragColor, color target at
+							// index 0 exists, otherwise shader is not modifying color
+							// targets.
+							hasFragData[0] |= hasFragColor || profile->id < 400;
+
+							if (!insert.isEmpty()
+							&&  profile->id < 400
+							&&  !hasFragColor)
+							{
+								insert = strInsert(const_cast<char*>(insert.getPtr()+1), "\ngl_FragColor = bgfx_VoidFrag;\n");
+							}
+						}
+
+						preprocessor.writef("#define void_main()");
+						preprocessor.writef(" \\\n\tvoid main(");
+
+						uint32_t arg = 0;
+
+						if (hasFragCoord)
+						{
+							preprocessor.writef(" \\\n\tvec4 gl_FragCoord : SV_POSITION");
+							++arg;
+						}
+
+						for (InOut::const_iterator it = shaderInputs.begin(), itEnd = shaderInputs.end(); it != itEnd; ++it)
+						{
+							VaryingMap::const_iterator varyingIt = varyingMap.find(*it);
+							if (varyingIt != varyingMap.end() )
+							{
+								const Varying& var = varyingIt->second;
+								preprocessor.writef(" \\\n\t%s%s %s %s : %s"
+									, arg++ > 0 ? ", " : "  "
+									, interpolationDx11(var.m_interpolation.c_str() )
+									, var.m_type.c_str()
+									, var.m_name.c_str()
+									, var.m_semantics.c_str()
+									);
+							}
+						}
+
+						const uint32_t maxRT = profile->id >= 400 ? BX_COUNTOF(hasFragData) : 4;
+
+						for (uint32_t ii = 0; ii < BX_COUNTOF(hasFragData); ++ii)
+						{
+							if (ii < maxRT)
+							{
+								if (hasFragData[ii])
+								{
+									addFragData(preprocessor, input, ii, arg++ > 0);
+								}
+							}
+							else
+							{
+								voidFragData(input, ii);
+							}
+						}
+
+						if (hasFragDepth)
+						{
+							preprocessor.writef(
+								" \\\n\t%sout float gl_FragDepth : SV_DEPTH"
+								, arg++ > 0 ? ", " : "  "
+								);
+						}
+
+						if (hasFrontFacing)
+						{
+							if (profile->id < 400)
+							{
+								preprocessor.writef(
+									" \\\n\t%sfloat __vface : VFACE"
+									, arg++ > 0 ? ", " : "  "
+									);
+							}
+							else
+							{
+								preprocessor.writef(
+									" \\\n\t%sbool gl_FrontFacing : SV_IsFrontFace"
+									, arg++ > 0 ? ", " : "  "
+									);
+							}
+						}
+
+						if (hasPrimitiveId)
+						{
+							if (profile->id >= 400)
+							{
+								preprocessor.writef(
+									" \\\n\t%suint gl_PrimitiveID : SV_PrimitiveID"
+									, arg++ > 0 ? ", " : "  "
+									);
+							}
+							else
+							{
+								bx::write(_messageWriter, &messageErr, "gl_PrimitiveID builtin is not supported by D3D9 HLSL.\n");
+								return false;
+							}
+						}
+
+						preprocessor.writef(
+							" \\\n\t)\n"
+							);
+
+						if (hasFrontFacing)
+						{
+							if (profile->id < 400)
+							{
+								preprocessor.writef(
+									"#define gl_FrontFacing (__vface >= 0.0)\n"
+									);
+							}
+						}
+					}
+					else if ('v' == _options.shaderType)
+					{
+						const bool hasVertexId   = !bx::strFind(input, "gl_VertexID").isEmpty();
+						const bool hasInstanceId = !bx::strFind(input, "gl_InstanceID").isEmpty();
+						const bool hasViewportId = !bx::strFind(input, "gl_ViewportIndex").isEmpty();
+						const bool hasLayerId    = !bx::strFind(input, "gl_Layer").isEmpty();
+
+						bx::StringView brace = bx::strFind(bx::StringView(entry.getPtr(), shader.getTerm() ), "{");
+						if (!brace.isEmpty() )
+						{
+							bx::StringView block = bx::strFindBlock(bx::StringView(brace.getPtr(), shader.getTerm() ), '{', '}');
+							if (!block.isEmpty() )
+							{
+								strInsert(const_cast<char*>(block.getTerm()-1), "__RETURN__;\n");
+							}
+						}
+
+						preprocessor.writef(
+							"struct Output\n"
+							"{\n"
+							"\tvec4 gl_Position : SV_POSITION;\n"
+							"#define gl_Position _varying_.gl_Position\n"
+							);
+
+						for (InOut::const_iterator it = shaderOutputs.begin(), itEnd = shaderOutputs.end(); it != itEnd; ++it)
+						{
+							VaryingMap::const_iterator varyingIt = varyingMap.find(*it);
+							if (varyingIt != varyingMap.end() )
+							{
+								const Varying& var = varyingIt->second;
+								preprocessor.writef(
+									  "\t%s %s %s : %s;\n"
+									, interpolationDx11(var.m_interpolation.c_str() )
+									, var.m_type.c_str()
+									, var.m_name.c_str()
+									, var.m_semantics.c_str()
+									);
+								preprocessor.writef(
+									  "#define %s _varying_.%s\n"
+									, var.m_name.c_str()
+									, var.m_name.c_str()
+									);
+							}
+						}
+
+						if (hasViewportId)
+						{
+							if (profile->id >= 400)
+							{
+								preprocessor.writef(
+									"\tuint gl_ViewportIndex : SV_ViewportArrayIndex;\n"
+									"#define gl_ViewportIndex _varying_.gl_ViewportIndex\n"
+									);
+							}
+							else
+							{
+								bx::write(_messageWriter, &messageErr, "gl_ViewportIndex builtin is not supported by D3D9 HLSL.\n");
+								return false;
+							}
+						}
+
+						if (hasLayerId)
+						{
+							if (profile->id >= 400)
+							{
+								preprocessor.writef(
+									"\tuint gl_Layer : SV_RenderTargetArrayIndex;\n"
+									"#define gl_Layer _varying_.gl_Layer\n"
+									);
+							}
+							else
+							{
+								bx::write(_messageWriter, &messageErr, "gl_Layer builtin is not supported by D3D9 HLSL.\n");
+								return false;
+							}
+						}
+
+						preprocessor.writef(
+							"};\n"
+							);
+
+						preprocessor.writef("#define void_main() \\\n");
+						preprocessor.writef("Output main(");
+						uint32_t arg = 0;
+						for (InOut::const_iterator it = shaderInputs.begin(), itEnd = shaderInputs.end(); it != itEnd; ++it)
+						{
+							VaryingMap::const_iterator varyingIt = varyingMap.find(*it);
+							if (varyingIt != varyingMap.end() )
+							{
+								const Varying& var = varyingIt->second;
+								preprocessor.writef(
+									" \\\n\t%s%s %s : %s"
+									, arg++ > 0 ? ", " : ""
+									, var.m_type.c_str()
+									, var.m_name.c_str()
+									, var.m_semantics.c_str()
+									);
+							}
+						}
+
+						if (hasVertexId)
+						{
+							if (profile->id >= 400)
+							{
+								preprocessor.writef(
+									" \\\n\t%suint gl_VertexID : SV_VertexID"
+									, arg++ > 0 ? ", " : "  "
+									);
+							}
+							else
+							{
+								bx::write(_messageWriter, &messageErr, "gl_VertexID builtin is not supported by D3D9 HLSL.\n");
+								return false;
+							}
+						}
+
+						if (hasInstanceId)
+						{
+							if (profile->id >= 400)
+							{
+								preprocessor.writef(
+									" \\\n\t%suint gl_InstanceID : SV_InstanceID"
+									, arg++ > 0 ? ", " : "  "
+									);
+							}
+							else
+							{
+								bx::write(_messageWriter, &messageErr, "gl_InstanceID builtin is not supported by D3D9 HLSL.\n");
+								return false;
+							}
+						}
+
+						preprocessor.writef(
+							") \\\n"
+							"{ \\\n"
+							"\tOutput _varying_;"
+							);
+
+						for (InOut::const_iterator it = shaderOutputs.begin(), itEnd = shaderOutputs.end(); it != itEnd; ++it)
+						{
+							VaryingMap::const_iterator varyingIt = varyingMap.find(*it);
+							if (varyingIt != varyingMap.end() )
+							{
+								const Varying& var = varyingIt->second;
+								preprocessor.writef(" \\\n\t%s", var.m_name.c_str() );
+								if (!var.m_init.empty() )
+								{
+									preprocessor.writef(" = %s", var.m_init.c_str() );
+								}
+								preprocessor.writef(";");
+							}
+						}
+
+						preprocessor.writef(
+							"\n#define __RETURN__ \\\n"
+							"\t} \\\n"
+							);
+
+						preprocessor.writef(
+							"\treturn _varying_"
+							);
+					}
+				}
+
+				if (preprocessor.run(input) )
+				{
+					if (_options.preprocessOnly)
+					{
+						bx::write(
+							_shaderWriter
+							, preprocessor.m_preprocessed.c_str()
+							, (int32_t)preprocessor.m_preprocessed.size()
+							, &err
+							);
+
+						return true;
+					}
+
+					{
+						std::string code;
+
+						if ('f' == _options.shaderType)
+						{
+							bx::write(_shaderWriter, BGFX_CHUNK_MAGIC_FSH, &err);
+							bx::write(_shaderWriter, inputHash, &err);
+							bx::write(_shaderWriter, uint32_t(0), &err);
+						}
+						else if ('v' == _options.shaderType)
+						{
+							bx::write(_shaderWriter, BGFX_CHUNK_MAGIC_VSH, &err);
+							bx::write(_shaderWriter, uint32_t(0), &err);
+							bx::write(_shaderWriter, outputHash, &err);
+						}
+						else
+						{
+							bx::write(_shaderWriter, BGFX_CHUNK_MAGIC_CSH, &err);
+							bx::write(_shaderWriter, uint32_t(0), &err);
+							bx::write(_shaderWriter, outputHash, &err);
+						}
+
+						if (profile->lang == ShadingLang::GLSL
+						||  profile->lang == ShadingLang::ESSL)
+						{
+							const bx::StringView preprocessedInput(preprocessor.m_preprocessed.c_str() );
+							uint32_t glsl_profile = profile->id;
+
+							const bool usesBitsToEncoders = true
+								&& _options.shaderType == 'f'
+								&& !bx::findIdentifierMatch(preprocessedInput, s_bitsToEncoders).isEmpty()
+								;
+
+							if (!bx::strFind(preprocessedInput, "layout(std430").isEmpty()
+							||  !bx::strFind(preprocessedInput, "image2D").isEmpty()
+							||  usesBitsToEncoders)
+							{
+								if (profile->lang == ShadingLang::GLSL
+								&&  glsl_profile < 430)
+								{
+									glsl_profile = 430;
+								}
+								else if (glsl_profile < 310)
+								{
+									glsl_profile = 310;
+								}
+							}
+
+							if (glsl_profile < 400)
+							{
+								const bool usesTextureLod   = false
+									|| !bx::findIdentifierMatch(input, s_ARB_shader_texture_lod).isEmpty()
+									|| !bx::findIdentifierMatch(input, s_EXT_shader_texture_lod).isEmpty()
+									;
+
+								const bool usesGpuShader5 = true
+									&& _options.shaderType != 'f'
+									&& !bx::findIdentifierMatch(input, s_ARB_gpu_shader5).isEmpty()
+									;
+
+								const bool usesInstanceID         = !bx::findIdentifierMatch(input, "gl_InstanceID").isEmpty();
+								const bool usesGpuShader4         = !bx::findIdentifierMatch(input, s_EXT_gpu_shader4).isEmpty();
+								const bool usesTexelFetch         = !bx::findIdentifierMatch(input, s_texelFetch).isEmpty();
+								const bool usesTextureMS          = !bx::findIdentifierMatch(input, s_ARB_texture_multisample).isEmpty();
+								const bool usesTextureArray       = !bx::findIdentifierMatch(input, s_textureArray).isEmpty();
+								const bool usesPacking            = !bx::findIdentifierMatch(input, s_ARB_shading_language_packing).isEmpty();
+								const bool usesViewportLayerArray = !bx::findIdentifierMatch(input, s_ARB_shader_viewport_layer_array).isEmpty();
+								const bool usesIntegerVecs        = !bx::findIdentifierMatch(preprocessedInput, s_integerVecs).isEmpty();
+
+								if (profile->lang != ShadingLang::ESSL)
+								{
+									const bool need130 = (120 == glsl_profile && (false
+										|| !bx::findIdentifierMatch(input, s_130).isEmpty()
+										|| usesInterpolationQualifiers
+										|| usesTexelFetch
+										|| usesIntegerVecs
+										) );
+
+									bx::stringPrintf(code, "#version %d\n", need130 ? 130 : glsl_profile);
+
+									if (need130)
+									{
+										bx::stringPrintf(code, "#define varying %s\n"
+											, 'f' == _options.shaderType ? "in" : "out"
+											);
+									}
+
+									if (usesInstanceID)
+									{
+										bx::stringPrintf(code
+											, "#extension GL_ARB_draw_instanced : enable\n"
+											);
+									}
+
+									if (usesViewportLayerArray)
+									{
+										bx::stringPrintf(code
+											, "#extension GL_ARB_shader_viewport_layer_array : enable\n"
+											);
+									}
+
+									if (usesGpuShader4)
+									{
+										bx::stringPrintf(code
+											, "#extension GL_EXT_gpu_shader4 : enable\n"
+											);
+									}
+
+									if (usesGpuShader5)
+									{
+										bx::stringPrintf(code
+											, "#extension GL_ARB_gpu_shader5 : enable\n"
+											);
+									}
+
+									if (usesPacking)
+									{
+										bx::stringPrintf(code
+											, "#extension GL_ARB_shading_language_packing : enable\n"
+											);
+									}
+
+									bool ARB_shader_texture_lod = false;
+									bool EXT_shader_texture_lod = false;
+
+									if (usesTextureLod)
+									{
+										if ('f' == _options.shaderType)
+										{
+											ARB_shader_texture_lod = true;
+											bx::stringPrintf(code
+												, "#extension GL_ARB_shader_texture_lod : enable\n"
+												);
+										}
+										else
+										{
+											EXT_shader_texture_lod = true;
+											bx::stringPrintf(code
+												, "#extension GL_EXT_shader_texture_lod : enable\n"
+												);
+										}
+									}
+
+									if (usesTextureMS)
+									{
+										bx::stringPrintf(code
+											, "#extension GL_ARB_texture_multisample : enable\n"
+											);
+									}
+
+									if (usesTextureArray)
+									{
+										bx::stringPrintf(code
+											, "#extension GL_EXT_texture_array : enable\n"
+											);
+									}
+
+									if (ARB_shader_texture_lod)
+									{
+										bx::stringPrintf(code,
+											"#define texture2DProjLod  texture2DProjLodARB\n"
+											"#define texture2DGrad     texture2DGradARB\n"
+											"#define texture2DProjGrad texture2DProjGradARB\n"
+											"#define textureCubeGrad   textureCubeGradARB\n"
+											);
+									}
+									else if (EXT_shader_texture_lod)
+									{
+										bx::stringPrintf(code,
+											"#define texture2DProjLod  texture2DProjLodEXT\n"
+											"#define texture2DGrad     texture2DGradEXT\n"
+											"#define texture2DProjGrad texture2DProjGradEXT\n"
+											"#define textureCubeGrad   textureCubeGradEXT\n"
+											);
+									}
+
+									if (need130 || (glsl_profile >= 130) )
+									{
+										bx::stringPrintf(code
+											, "#define bgfxShadow2D(_sampler, _coord)     vec4_splat(texture(_sampler, _coord) )\n"
+											  "#define bgfxShadow2DProj(_sampler, _coord) vec4_splat(textureProj(_sampler, _coord) )\n"
+											);
+									}
+									else
+									{
+										bx::stringPrintf(code
+											, "#define bgfxShadow2D     shadow2D\n"
+											  "#define bgfxShadow2DProj shader2DProj\n"
+											);
+									}
+								}
+								else
+								{
+									if (glsl_profile < 300
+									&&  usesIntegerVecs)
+									{
+										glsl_profile = 300;
+									}
+
+									if (glsl_profile > 100)
+									{
+										bx::stringPrintf(code, "#version %d es\n", glsl_profile);
+										bx::stringPrintf(code, "#define attribute in\n");
+										bx::stringPrintf(code, "#define varying %s\n"
+											, 'f' == _options.shaderType ? "in" : "out"
+											);
+										bx::stringPrintf(code, "precision highp float;\n");
+										bx::stringPrintf(code, "precision highp int;\n");
+									}
+
+									if (glsl_profile >= 300 && usesTextureArray)
+									{
+										bx::stringPrintf(code, "precision highp sampler2DArray;\n");
+									}
+
+									// Pretend that all extensions are available.
+									// This will be stripped later.
+									if (usesTextureLod)
+									{
+										bx::stringPrintf(code
+											, "#extension GL_EXT_shader_texture_lod : enable\n"
+											  "#define texture2DLod      texture2DLodEXT\n"
+											  "#define texture2DGrad     texture2DGradEXT\n"
+											  "#define texture2DProjLod  texture2DProjLodEXT\n"
+											  "#define texture2DProjGrad texture2DProjGradEXT\n"
+											  "#define textureCubeLod    textureCubeLodEXT\n"
+											  "#define textureCubeGrad   textureCubeGradEXT\n"
+											);
+									}
+
+									if (!bx::findIdentifierMatch(input, s_OES_standard_derivatives).isEmpty() )
+									{
+										bx::stringPrintf(code, "#extension GL_OES_standard_derivatives : enable\n");
+									}
+
+									if (!bx::findIdentifierMatch(input, s_OES_texture_3D).isEmpty() )
+									{
+										bx::stringPrintf(code, "#extension GL_OES_texture_3D : enable\n");
+									}
+
+									if (glsl_profile < 300
+									&&  !bx::findIdentifierMatch(input, s_EXT_shadow_samplers).isEmpty() )
+									{
+										bx::stringPrintf(code
+											, "#extension GL_EXT_shadow_samplers : enable\n"
+											  "#define shadow2D shadow2DEXT\n"
+											  "#define shadow2DProj shadow2DProjEXT\n"
+											);
+									}
+									else
+									{
+										bx::stringPrintf(code
+											, "#define shadow2D(_sampler, _coord) texture(_sampler, _coord)\n"
+											  "#define shadow2DProj(_sampler, _coord) textureProj(_sampler, _coord)\n"
+											);
+									}
+
+									if (usesGpuShader5)
+									{
+										bx::stringPrintf(code
+											, "#extension GL_ARB_gpu_shader5 : enable\n"
+											);
+									}
+
+									if (usesPacking)
+									{
+										bx::stringPrintf(code
+											, "#extension GL_ARB_shading_language_packing : enable\n"
+											);
+									}
+
+									if (glsl_profile < 300
+									&&  !bx::findIdentifierMatch(input, "gl_FragDepth").isEmpty() )
+									{
+										bx::stringPrintf(code
+											, "#extension GL_EXT_frag_depth : enable\n"
+											  "#define gl_FragDepth gl_FragDepthEXT\n"
+											);
+									}
+
+									if (usesTextureArray)
+									{
+										bx::stringPrintf(code
+											, "#extension GL_EXT_texture_array : enable\n"
+											);
+									}
+
+									if (glsl_profile == 100)
+									{
+										code +=
+											"mat2 transpose(mat2 _mtx)\n"
+											"{\n"
+											"	vec2 v0 = _mtx[0];\n"
+											"	vec2 v1 = _mtx[1];\n"
+											"\n"
+											"	return mat2(\n"
+											"		  vec2(v0.x, v1.x)\n"
+											"		, vec2(v0.y, v1.y)\n"
+											"		);\n"
+											"}\n"
+											"\n"
+											"mat3 transpose(mat3 _mtx)\n"
+											"{\n"
+											"	vec3 v0 = _mtx[0];\n"
+											"	vec3 v1 = _mtx[1];\n"
+											"	vec3 v2 = _mtx[2];\n"
+											"\n"
+											"	return mat3(\n"
+											"		  vec3(v0.x, v1.x, v2.x)\n"
+											"		, vec3(v0.y, v1.y, v2.y)\n"
+											"		, vec3(v0.z, v1.z, v2.z)\n"
+											"		);\n"
+											"}\n"
+											"\n"
+											"mat4 transpose(mat4 _mtx)\n"
+											"{\n"
+											"	vec4 v0 = _mtx[0];\n"
+											"	vec4 v1 = _mtx[1];\n"
+											"	vec4 v2 = _mtx[2];\n"
+											"	vec4 v3 = _mtx[3];\n"
+											"\n"
+											"	return mat4(\n"
+											"		  vec4(v0.x, v1.x, v2.x, v3.x)\n"
+											"		, vec4(v0.y, v1.y, v2.y, v3.y)\n"
+											"		, vec4(v0.z, v1.z, v2.z, v3.z)\n"
+											"		, vec4(v0.w, v1.w, v2.w, v3.w)\n"
+											"		);\n"
+											"}\n"
+											;
+									}
+								}
+							}
+							else
+							{
+								bx::stringPrintf(code, "#version %d\n", glsl_profile);
+
+								if (120 < glsl_profile)
+								{
+									if (!bx::findIdentifierMatch(input, "gl_FragColor").isEmpty() )
+									{
+										bx::stringPrintf(code
+											, "out vec4 bgfx_FragColor;\n"
+											  "#define gl_FragColor bgfx_FragColor\n"
+											);
+									}
+								}
+
+								bx::stringPrintf(code
+									, "#define texture2D          texture\n"
+									  "#define texture2DLod       textureLod\n"
+									  "#define texture2DGrad      textureGrad\n"
+									  "#define texture2DProjLod   textureProjLod\n"
+									  "#define texture2DProjGrad  textureProjGrad\n"
+									  "#define textureCubeLod     textureLod\n"
+									  "#define textureCubeGrad    textureGrad\n"
+									  "#define texture3D          texture\n"
+									  "#define texture2DLodOffset textureLodOffset\n"
+									);
+
+								bx::stringPrintf(code, "#define attribute in\n");
+								bx::stringPrintf(code, "#define varying %s\n"
+									, 'f' == _options.shaderType ? "in" : "out"
+									);
+
+								bx::stringPrintf(code
+									, "#define bgfxShadow2D(_sampler, _coord)     vec4_splat(texture(_sampler, _coord) )\n"
+									  "#define bgfxShadow2DProj(_sampler, _coord) vec4_splat(textureProj(_sampler, _coord) )\n"
+									);
+							}
+
+							if ( (profile->lang == ShadingLang::GLSL && glsl_profile > 400)
+							||   (profile->lang == ShadingLang::ESSL && glsl_profile > 300) )
+							{
+								code += preprocessor.m_preprocessed;
+
+								bx::write(_shaderWriter, uint16_t(0), &err);
+
+								uint32_t shaderSize = (uint32_t)code.size();
+								bx::write(_shaderWriter, shaderSize, &err);
+								bx::write(_shaderWriter, code.c_str(), shaderSize, &err);
+								bx::write(_shaderWriter, uint8_t(0), &err);
+
+								compiled = true;
+							}
+							else
+							{
+								code += _comment;
+								code += preprocessor.m_preprocessed;
+
+								if (profile->lang == ShadingLang::ESSL)
+								{
+									glsl_profile |= 0x80000000;
+								}
+
+								compiled = compileGLSLShader(_options, glsl_profile, code, _shaderWriter, _messageWriter);
+							}
+						}
+						else
+						{
+							code += _comment;
+							code += preprocessor.m_preprocessed;
+
+							if (profile->lang == ShadingLang::Metal)
+							{
+								compiled = compileMetalShader(_options, profile->id, code, _shaderWriter, _messageWriter);
+							}
+							else if (profile->lang == ShadingLang::SpirV)
+							{
+								compiled = compileSPIRVShader(_options, profile->id, code, _shaderWriter, _messageWriter);
+							}
+							else if (profile->lang == ShadingLang::PSSL)
+							{
+								compiled = compilePSSLShader(_options, 0, code, _shaderWriter, _messageWriter);
+							}
+							else
+							{
+								compiled = compileHLSLShader(_options, profile->id, code, _shaderWriter, _messageWriter);
+							}
+						}
+					}
+
+					if (compiled)
+					{
+						if (_options.depends)
+						{
+							std::string ofp = _options.outputFilePath + ".d";
+							bx::FileWriter writer;
+							if (bx::open(&writer, ofp.c_str() ) )
+							{
+								writef(&writer, "%s : %s\n", _options.outputFilePath.c_str(), preprocessor.m_depends.c_str() );
+								bx::close(&writer);
+							}
+						}
+					}
+				}
+			}
+		}
+
+		delete [] data;
+
+		return compiled;
+	}
+
+	int compileShader(int _argc, const char* _argv[])
+	{
+		bx::CommandLine cmdLine(_argc, _argv);
+
+		if (cmdLine.hasArg('v', "version") )
+		{
+			bx::printf(
+				  "shaderc, bgfx shader compiler tool, version %d.%d.%d.\n"
+				, BGFX_SHADERC_VERSION_MAJOR
+				, BGFX_SHADERC_VERSION_MINOR
+				, BGFX_API_VERSION
+				);
+			return bx::kExitSuccess;
+		}
+
+		if (cmdLine.hasArg('h', "help") )
+		{
+			help();
+			return bx::kExitFailure;
+		}
+
+		g_verbose = cmdLine.hasArg("verbose");
+
+		const char* filePath = cmdLine.findOption('f');
+		if (NULL == filePath)
+		{
+			help("Shader file name must be specified.");
+			return bx::kExitFailure;
+		}
+
+		bool consoleOut = cmdLine.hasArg("stdout");
+		const char* outFilePath = cmdLine.findOption('o');
+		if (NULL == outFilePath
+		&&  !consoleOut)
+		{
+			help("Output file name must be specified or use \"--stdout\" to output to stdout.");
+			return bx::kExitFailure;
+		}
+
+		const char* type = cmdLine.findOption('\0', "type");
+		if (NULL == type)
+		{
+			help("Must specify shader type.");
+			return bx::kExitFailure;
+		}
+
+		Options options;
+		options.inputFilePath = filePath;
+		options.outputFilePath = consoleOut ? "" : outFilePath;
+		options.shaderType = bx::toLower(type[0]);
+
+		options.disasm = cmdLine.hasArg('\0', "disasm");
+
+		const char* platform = cmdLine.findOption('\0', "platform");
+		if (NULL == platform)
+		{
+			platform = "";
+		}
+
+		options.platform = platform;
+
+		options.raw = cmdLine.hasArg('\0', "raw");
+
+		const char* profile = cmdLine.findOption('p', "profile");
+
+		if ( NULL != profile)
+		{
+			options.profile = profile;
+		}
+
+		{
+			options.debugInformation       = cmdLine.hasArg('\0', "debug");
+			options.avoidFlowControl       = cmdLine.hasArg('\0', "avoid-flow-control");
+			options.noPreshader            = cmdLine.hasArg('\0', "no-preshader");
+			options.partialPrecision       = cmdLine.hasArg('\0', "partial-precision");
+			options.preferFlowControl      = cmdLine.hasArg('\0', "prefer-flow-control");
+			options.backwardsCompatibility = cmdLine.hasArg('\0', "backwards-compatibility");
+			options.warningsAreErrors      = cmdLine.hasArg('\0', "Werror");
+			options.keepIntermediate       = cmdLine.hasArg('\0', "keep-intermediate");
+
+			uint32_t optimization = 3;
+			if (cmdLine.hasArg(optimization, 'O') )
+			{
+				options.optimize = true;
+				options.optimizationLevel = optimization;
+			}
+		}
+
+		bx::StringView bin2c;
+		if (cmdLine.hasArg("bin2c") )
+		{
+			const char* bin2cArg = cmdLine.findOption("bin2c");
+			if (NULL != bin2cArg)
+			{
+				bin2c.set(bin2cArg);
+			}
+			else
+			{
+				bin2c = baseName(outFilePath);
+				if (!bin2c.isEmpty() )
+				{
+					char* temp = (char*)BX_STACK_ALLOC(bin2c.getLength()+1);
+					for (uint32_t ii = 0, num = bin2c.getLength(); ii < num; ++ii)
+					{
+						char ch = bin2c.getPtr()[ii];
+						if (bx::isAlphaNum(ch) )
+						{
+							temp[ii] = ch;
+						}
+						else
+						{
+							temp[ii] = '_';
+						}
+					}
+
+					temp[bin2c.getLength()] = '\0';
+
+					bin2c = temp;
+				}
+			}
+		}
+
+		options.depends = cmdLine.hasArg("depends");
+		options.preprocessOnly = cmdLine.hasArg("preprocess");
+		const char* includeDir = cmdLine.findOption('i');
+
+		BX_TRACE("depends: %d", options.depends);
+		BX_TRACE("preprocessOnly: %d", options.preprocessOnly);
+		BX_TRACE("includeDir: %s", includeDir);
+
+		for (int ii = 1; NULL != includeDir; ++ii)
+		{
+			options.includeDirs.push_back(includeDir);
+			includeDir = cmdLine.findOption(ii, 'i');
+		}
+
+		std::string dir;
+		{
+			bx::FilePath fp(filePath);
+			bx::StringView path(fp.getPath() );
+
+			dir.assign(path.getPtr(), path.getTerm() );
+			options.includeDirs.push_back(dir);
+		}
+
+		const char* defines = cmdLine.findOption("define");
+		while (NULL != defines
+		&&    '\0'  != *defines)
+		{
+			defines = bx::strLTrimSpace(defines).getPtr();
+			bx::StringView eol = bx::strFind(defines, ';');
+			std::string define(defines, eol.getPtr() );
+			options.defines.push_back(define.c_str() );
+			defines = ';' == *eol.getPtr() ? eol.getPtr()+1 : eol.getPtr();
+		}
+
+		std::string commandLineComment = "// shaderc command line:\n//";
+		for (int32_t ii = 0, num = cmdLine.getNum(); ii < num; ++ii)
+		{
+			commandLineComment += " ";
+			commandLineComment += cmdLine.get(ii);
+		}
+		commandLineComment += "\n\n";
+
+		bool compiled = false;
+
+		bx::FileReader reader;
+		if (!bx::open(&reader, filePath) )
+		{
+			bx::printf("Unable to open file '%s'.\n", filePath);
+		}
+		else
+		{
+			const char* varying = NULL;
+			File attribdef;
+
+			if ('c' != options.shaderType)
+			{
+				std::string defaultVarying = dir + "varying.def.sc";
+				const char* varyingdef = cmdLine.findOption("varyingdef", defaultVarying.c_str() );
+				attribdef.load(varyingdef);
+				varying = attribdef.getData();
+
+				if (NULL     != varying
+				&&  *varying != '\0')
+				{
+					options.dependencies.push_back(varyingdef);
+				}
+				else
+				{
+					bx::printf("ERROR: Failed to parse varying def file: \"%s\" No input/output semantics will be generated in the code!\n", varyingdef);
+				}
+			}
+
+			int32_t size = (int32_t)bx::getSize(&reader);
+			const int32_t total = size + 16384;
+			char* data = new char[total];
+			size = bx::read(&reader, data, size, bx::ErrorAssert{});
+
+			// Trim UTF-8 BOM
+			if (data[0] == '\xef'
+			&&  data[1] == '\xbb'
+			&&  data[2] == '\xbf')
+			{
+				bx::memMove(data, &data[3], size-3);
+				size -= 3;
+			}
+
+			const char ch = data[0];
+			if (false // https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding
+			||  '\x00' == ch
+			||  '\x0e' == ch
+			||  '\x2b' == ch
+			||  '\x84' == ch
+			||  '\xdd' == ch
+			||  '\xf7' == ch
+			||  '\xfb' == ch
+			||  '\xfe' == ch
+			||  '\xff' == ch
+			   )
+			{
+				bx::printf("Shader input file has unsupported BOM.\n");
+				return bx::kExitFailure;
+			}
+
+			// Compiler generates "error X3000: syntax error: unexpected end of file"
+			// if input doesn't have empty line at EOF.
+			data[size] = '\n';
+			bx::memSet(&data[size+1], 0, total-size-1);
+			bx::close(&reader);
+
+			{
+				bx::FileWriter* writer = NULL;
+
+				if (!consoleOut)
+				{
+					if (!bin2c.isEmpty() )
+					{
+						writer = new Bin2cWriter(bin2c);
+					}
+					else
+					{
+						writer = new bx::FileWriter;
+					}
+
+					if (!bx::open(writer, outFilePath) )
+					{
+						bx::printf("Unable to open output file '%s'.\n", outFilePath);
+						return bx::kExitFailure;
+					}
+				}
+
+				compiled = compileShader(
+						  varying
+						, commandLineComment.c_str()
+						, data
+						, size
+						, options
+						, consoleOut ? bx::getStdOut() : writer
+						, bx::getStdOut()
+						);
+
+				if (!consoleOut)
+				{
+					bx::close(writer);
+					delete writer;
+				}
+			}
+		}
+
+		if (compiled)
+		{
+			return bx::kExitSuccess;
+		}
+
+		bx::remove(outFilePath);
+
+		bx::printf("Failed to build shader.\n");
+		return bx::kExitFailure;
+	}
+
+} // namespace bgfx
+
+int main(int _argc, const char* _argv[])
+{
+	return bgfx::compileShader(_argc, _argv);
+}
diff --git a/brtshaderc/shaderc.h b/brtshaderc/shaderc.h
new file mode 100644
index 0000000..cd9fdbf
--- /dev/null
+++ b/brtshaderc/shaderc.h
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2011-2025 Branimir Karadzic. All rights reserved.
+ * License: https://github.com/bkaradzic/bgfx/blob/master/LICENSE
+ */
+
+#ifndef SHADERC_H_HEADER_GUARD
+#define SHADERC_H_HEADER_GUARD
+
+namespace bgfx
+{
+	extern bool g_verbose;
+}
+
+#ifndef SHADERC_CONFIG_HLSL
+#	define SHADERC_CONFIG_HLSL BX_PLATFORM_WINDOWS
+#endif // SHADERC_CONFIG_HLSL
+
+#include <bx/bx.h>
+#include <bx/debug.h>
+#include <bx/commandline.h>
+#include <bx/endian.h>
+#include <bx/uint32_t.h>
+#include <bx/string.h>
+#include <bx/hash.h>
+#include <bx/file.h>
+#include "../../src/vertexlayout.h"
+
+#include <string.h>
+#include <algorithm>
+#include <string>
+#include <vector>
+#include <unordered_map>
+
+namespace bgfx
+{
+	extern bool g_verbose;
+
+	bx::StringView nextWord(bx::StringView& _parse);
+
+	constexpr uint8_t kUniformFragmentBit  = 0x10;
+	constexpr uint8_t kUniformSamplerBit   = 0x20;
+	constexpr uint8_t kUniformReadOnlyBit  = 0x40;
+	constexpr uint8_t kUniformCompareBit   = 0x80;
+	constexpr uint8_t kUniformMask = 0
+		| kUniformFragmentBit
+		| kUniformSamplerBit
+		| kUniformReadOnlyBit
+		| kUniformCompareBit
+		;
+
+	const char* shaderc_getUniformTypeName(UniformType::Enum _enum);
+	UniformType::Enum shaderc_nameToUniformTypeEnum(const char* _name);
+
+	struct Uniform
+	{
+		Uniform()
+			: type(UniformType::Count)
+			, num(0)
+			, regIndex(0)
+			, regCount(0)
+			, texComponent(0)
+			, texDimension(0)
+			, texFormat(0)
+		{
+		}
+
+		std::string name;
+		UniformType::Enum type;
+		uint8_t num;
+		uint16_t regIndex;
+		uint16_t regCount;
+		uint8_t texComponent;
+		uint8_t texDimension;
+		uint16_t texFormat;
+	};
+
+	struct Options
+	{
+		Options();
+
+		void dump();
+
+		char shaderType;
+		std::string platform;
+		std::string profile;
+
+		std::string	inputFilePath;
+		std::string	outputFilePath;
+
+		std::vector<std::string> includeDirs;
+		std::vector<std::string> defines;
+		std::vector<std::string> dependencies;
+
+		bool disasm;
+		bool raw;
+		bool preprocessOnly;
+		bool depends;
+
+		bool debugInformation;
+
+		bool avoidFlowControl;
+		bool noPreshader;
+		bool partialPrecision;
+		bool preferFlowControl;
+		bool backwardsCompatibility;
+		bool warningsAreErrors;
+		bool keepIntermediate;
+
+		bool optimize;
+		uint32_t optimizationLevel;
+	};
+
+	typedef std::vector<Uniform> UniformArray;
+
+	void printCode(const char* _code, int32_t _line = 0, int32_t _start = 0, int32_t _end = INT32_MAX, int32_t _column = -1);
+	void strReplace(char* _str, const char* _find, const char* _replace);
+	int32_t writef(bx::WriterI* _writer, const char* _format, ...);
+	void writeFile(const char* _filePath, const void* _data, int32_t _size);
+
+	bool compileGLSLShader(const Options& _options, uint32_t _version, const std::string& _code, bx::WriterI* _writer, bx::WriterI* _messages);
+	bool compileHLSLShader(const Options& _options, uint32_t _version, const std::string& _code, bx::WriterI* _writer, bx::WriterI* _messages);
+	bool compileMetalShader(const Options& _options, uint32_t _version, const std::string& _code, bx::WriterI* _writer, bx::WriterI* _messages);
+	bool compilePSSLShader(const Options& _options, uint32_t _version, const std::string& _code, bx::WriterI* _writer, bx::WriterI* _messages);
+	bool compileSPIRVShader(const Options& _options, uint32_t _version, const std::string& _code, bx::WriterI* _writer, bx::WriterI* _messages);
+
+	const char* getPsslPreamble();
+
+} // namespace bgfx
+
+#endif // SHADERC_H_HEADER_GUARD
diff --git a/brtshaderc/shaderc_glsl.cpp b/brtshaderc/shaderc_glsl.cpp
new file mode 100644
index 0000000..ce751c2
--- /dev/null
+++ b/brtshaderc/shaderc_glsl.cpp
@@ -0,0 +1,404 @@
+/*
+ * Copyright 2011-2025 Branimir Karadzic. All rights reserved.
+ * License: https://github.com/bkaradzic/bgfx/blob/master/LICENSE
+ */
+
+#include "shaderc.h"
+#include "glsl_optimizer.h"
+
+namespace bgfx { namespace glsl
+{
+	static bool compile(const Options& _options, uint32_t _version, const std::string& _code, bx::WriterI* _shaderWriter, bx::WriterI* _messageWriter)
+	{
+		bx::ErrorAssert messageErr;
+
+		char ch = _options.shaderType;
+		const glslopt_shader_type type = ch == 'f'
+			? kGlslOptShaderFragment
+			: (ch == 'c' ? kGlslOptShaderCompute : kGlslOptShaderVertex);
+
+		glslopt_target target = kGlslTargetOpenGL;
+		if(_version == BX_MAKEFOURCC('M', 'T', 'L', 0))
+		{
+			target = kGlslTargetMetal;
+		} else if(_version < 0x80000000) {
+			target = kGlslTargetOpenGL;
+		}
+		else {
+			_version &= ~0x80000000;
+			target = (_version >= 300) ? kGlslTargetOpenGLES30 : kGlslTargetOpenGLES20;
+		}
+
+		glslopt_ctx* ctx = glslopt_initialize(target);
+
+		glslopt_shader* shader = glslopt_optimize(ctx, type, _code.c_str(), 0);
+
+		if (!glslopt_get_status(shader) )
+		{
+			const char* log = glslopt_get_log(shader);
+			int32_t source  = 0;
+			int32_t line    = 0;
+			int32_t column  = 0;
+			int32_t start   = 0;
+			int32_t end     = INT32_MAX;
+
+			bool found = false
+				|| 3 == sscanf(log, "%u:%u(%u):", &source, &line, &column)
+				|| 2 == sscanf(log, "(%u,%u):", &line, &column)
+				;
+
+			if (found
+			&&  0 != line)
+			{
+				start = bx::uint32_imax(1, line-10);
+				end   = start + 20;
+			}
+
+			printCode(_code.c_str(), line, start, end, column);
+			bx::write(_messageWriter, &messageErr, "Error: %s\n", log);
+			glslopt_shader_delete(shader);
+			glslopt_cleanup(ctx);
+			return false;
+		}
+
+		const char* optimizedShader = glslopt_get_output(shader);
+
+		std::string out;
+		// Trim all directives.
+		while ('#' == *optimizedShader)
+		{
+			optimizedShader = bx::strFindNl(optimizedShader).getPtr();
+		}
+
+		out.append(optimizedShader, strlen(optimizedShader));
+		optimizedShader = out.c_str();
+
+		{
+			char* code = const_cast<char*>(optimizedShader);
+			strReplace(code, "gl_FragDepthEXT", "gl_FragDepth");
+
+			strReplace(code, "textureLodEXT", "texture2DLod");
+			strReplace(code, "textureGradEXT", "texture2DGrad");
+
+			strReplace(code, "texture2DLodARB", "texture2DLod");
+			strReplace(code, "texture2DLodEXT", "texture2DLod");
+			strReplace(code, "texture2DGradARB", "texture2DGrad");
+			strReplace(code, "texture2DGradEXT", "texture2DGrad");
+
+			strReplace(code, "textureCubeLodARB", "textureCubeLod");
+			strReplace(code, "textureCubeLodEXT", "textureCubeLod");
+			strReplace(code, "textureCubeGradARB", "textureCubeGrad");
+			strReplace(code, "textureCubeGradEXT", "textureCubeGrad");
+
+			strReplace(code, "texture2DProjLodARB", "texture2DProjLod");
+			strReplace(code, "texture2DProjLodEXT", "texture2DProjLod");
+			strReplace(code, "texture2DProjGradARB", "texture2DProjGrad");
+			strReplace(code, "texture2DProjGradEXT", "texture2DProjGrad");
+
+			strReplace(code, "shadow2DARB", "shadow2D");
+			strReplace(code, "shadow2DEXT", "shadow2D");
+			strReplace(code, "shadow2DProjARB", "shadow2DProj");
+			strReplace(code, "shadow2DProjEXT", "shadow2DProj");
+		}
+
+		UniformArray uniforms;
+
+		if (target != kGlslTargetMetal)
+		{
+			bx::StringView parse(optimizedShader);
+
+			while (!parse.isEmpty() )
+			{
+				parse = bx::strLTrimSpace(parse);
+				bx::StringView eol = bx::strFind(parse, ';');
+				if (!eol.isEmpty() )
+				{
+					bx::StringView qualifier = nextWord(parse);
+
+					if (0 == bx::strCmp(qualifier, "precision", 9) )
+					{
+						// skip precision
+						parse.set(eol.getPtr() + 1, parse.getTerm() );
+						continue;
+					}
+
+					if (0 == bx::strCmp(qualifier, "attribute", 9)
+					||  0 == bx::strCmp(qualifier, "varying",   7)
+					||  0 == bx::strCmp(qualifier, "in",        2)
+					||  0 == bx::strCmp(qualifier, "out",       3)
+					   )
+					{
+						// skip attributes and varyings.
+						parse.set(eol.getPtr() + 1, parse.getTerm() );
+						continue;
+					}
+
+					if (0 == bx::strCmp(qualifier, "flat", 4)
+					||  0 == bx::strCmp(qualifier, "smooth", 6)
+					||  0 == bx::strCmp(qualifier, "noperspective", 13)
+					||  0 == bx::strCmp(qualifier, "centroid", 8)
+					   )
+					{
+						// skip interpolation qualifiers
+						parse.set(eol.getPtr() + 1, parse.getTerm() );
+						continue;
+					}
+
+					if (0 == bx::strCmp(parse, "tmpvar", 6) )
+					{
+						// skip temporaries
+						parse.set(eol.getPtr() + 1, parse.getTerm() );
+						continue;
+					}
+
+					if (0 != bx::strCmp(qualifier, "uniform", 7) )
+					{
+						// end if there is no uniform keyword.
+						parse.clear();
+						continue;
+					}
+
+					bx::StringView precision;
+					bx::StringView typen = nextWord(parse);
+
+					if (0 == bx::strCmp(typen, "lowp", 4)
+					||  0 == bx::strCmp(typen, "mediump", 7)
+					||  0 == bx::strCmp(typen, "highp", 5) )
+					{
+						precision = typen;
+						typen = nextWord(parse);
+					}
+
+					BX_UNUSED(precision);
+
+					char uniformType[256];
+
+					if (0 == bx::strCmp(typen, "sampler", 7)
+					||  0 == bx::strCmp(typen, "isampler", 8)
+					||  0 == bx::strCmp(typen, "usampler", 8) )
+					{
+						bx::strCopy(uniformType, BX_COUNTOF(uniformType), "int");
+					}
+					else
+					{
+						bx::strCopy(uniformType, BX_COUNTOF(uniformType), typen);
+					}
+
+					bx::StringView name = nextWord(parse);
+
+					uint8_t num = 1;
+					bx::StringView array = bx::strSubstr(parse, 0, 1);
+					if (0 == bx::strCmp(array, "[", 1) )
+					{
+						parse = bx::strLTrimSpace(bx::StringView(parse.getPtr() + 1, parse.getTerm() ) );
+
+						uint32_t tmp;
+						bx::fromString(&tmp, parse);
+						num = uint8_t(tmp);
+					}
+
+					Uniform un;
+					un.type = shaderc_nameToUniformTypeEnum(uniformType);
+
+					if (UniformType::Count != un.type)
+					{
+						un.name.assign(name.getPtr(), name.getTerm());
+
+						BX_TRACE("name: %s (type %d, num %d)", un.name.c_str(), un.type, num);
+
+						un.num = num;
+						un.regIndex = 0;
+						un.regCount = num;
+						switch (un.type)
+						{
+						case UniformType::Mat3:
+							un.regCount *= 3;
+							break;
+						case UniformType::Mat4:
+							un.regCount *= 4;
+							break;
+						default:
+							break;
+						}
+
+						uniforms.push_back(un);
+					}
+
+					parse = bx::strLTrimSpace(bx::strFindNl(bx::StringView(eol.getPtr(), parse.getTerm() ) ) );
+				}
+			}
+		}
+		else
+		{
+			const bx::StringView optShader(optimizedShader);
+			bx::StringView parse = bx::strFind(optimizedShader, "struct xlatMtlShaderUniform {");
+			bx::StringView end   = parse;
+			if (!parse.isEmpty() )
+			{
+				parse.set(parse.getPtr() + bx::strLen("struct xlatMtlShaderUniform {"), optShader.getTerm() );
+				end = bx::strFind(parse, "};");
+			}
+
+			while ( parse.getPtr() < end.getPtr()
+			&&     !parse.isEmpty() )
+			{
+				parse.set(bx::strLTrimSpace(parse).getPtr(), optShader.getTerm() );
+				const bx::StringView eol = bx::strFind(parse, ';');
+				if (!eol.isEmpty() )
+				{
+					const char* typen = parse.getPtr();
+
+					char uniformType[256];
+					parse = bx::strWord(parse);
+					bx::strCopy(uniformType, parse.getLength()+1, typen);
+					parse.set(parse.getPtr()+parse.getLength(),optShader.getTerm());
+					const char* name = bx::strLTrimSpace(parse).getPtr();
+					parse.set(name, optShader.getTerm() );
+
+					char uniformName[256];
+					uint8_t num = 1;
+					bx::StringView array = bx::strFind(bx::StringView(name, int32_t(eol.getPtr()-parse.getPtr() ) ), "[");
+					if (!array.isEmpty() )
+					{
+						bx::strCopy(uniformName, int32_t(array.getPtr()-name+1), name);
+
+						char arraySize[32];
+						bx::StringView arrayEnd = bx::strFind(bx::StringView(array.getPtr(), int32_t(eol.getPtr()-array.getPtr() ) ), "]");
+						bx::strCopy(arraySize, int32_t(arrayEnd.getPtr()-array.getPtr() ), array.getPtr()+1);
+						uint32_t tmp;
+						bx::fromString(&tmp, arraySize);
+						num = uint8_t(tmp);
+					}
+					else
+					{
+						bx::strCopy(uniformName, int32_t(eol.getPtr()-name+1), name);
+					}
+
+					Uniform un;
+					un.type = shaderc_nameToUniformTypeEnum(uniformType);
+
+					if (UniformType::Count != un.type)
+					{
+						BX_TRACE("name: %s (type %d, num %d)", uniformName, un.type, num);
+
+						un.name = uniformName;
+						un.num = num;
+						un.regIndex = 0;
+						un.regCount = num;
+						uniforms.push_back(un);
+					}
+
+					parse = eol.getPtr() + 1;
+				}
+			}
+
+			bx::StringView mainEntry("xlatMtlShaderOutput xlatMtlMain (");
+			parse = bx::strFind(optimizedShader, mainEntry);
+			end = parse;
+			if (!parse.isEmpty())
+			{
+				parse.set(parse.getPtr() + mainEntry.getLength(), optShader.getTerm());
+				end = bx::strFind(parse, "{");
+			}
+
+			while (parse.getPtr() < end.getPtr()
+				&& !parse.isEmpty())
+			{
+				parse.set(bx::strLTrimSpace(parse).getPtr(), optShader.getTerm());
+				const bx::StringView textureNameMark("[[texture(");
+				const bx::StringView textureName = bx::strFind(parse, textureNameMark);
+
+				if (!textureName.isEmpty())
+				{
+					Uniform un;
+					un.type = shaderc_nameToUniformTypeEnum("int");	// int for sampler
+					const char* varNameEnd = textureName.getPtr() - 1;
+					parse.set(parse.getPtr(), varNameEnd - 1);
+					const char* varNameBeg = parse.getPtr();
+					for (int ii = parse.getLength() - 1; 0 <= ii; --ii)
+					{
+						if (varNameBeg[ii] == ' ')
+						{
+							parse.set(varNameBeg + ii + 1, varNameEnd);
+							break;
+						}
+					}
+					char uniformName[256];
+					bx::strCopy(uniformName, parse.getLength() + 1, parse);
+					un.name = uniformName;
+					const char* regIndexBeg = textureName.getPtr() + textureNameMark.getLength();
+					bx::StringView regIndex = bx::strFind(regIndexBeg, ")");
+
+					regIndex.set(regIndexBeg, regIndex.getPtr());
+					uint32_t tmp;
+					bx::fromString(&tmp, regIndex);
+					un.regIndex = uint16_t(tmp);
+					un.num = 1;
+					un.regCount = 1;
+
+					uniforms.push_back(un);
+
+					parse = regIndex.getPtr() + 1;
+				}
+				else
+				{
+					parse = textureName;
+				}
+			}
+		}
+
+		bx::ErrorAssert err;
+
+		uint16_t count = (uint16_t)uniforms.size();
+		bx::write(_shaderWriter, count, &err);
+
+		for (UniformArray::const_iterator it = uniforms.begin(); it != uniforms.end(); ++it)
+		{
+			const Uniform& un = *it;
+			uint8_t nameSize = (uint8_t)un.name.size();
+			bx::write(_shaderWriter, nameSize, &err);
+			bx::write(_shaderWriter, un.name.c_str(), nameSize, &err);
+			uint8_t uniformType = uint8_t(un.type);
+			bx::write(_shaderWriter, uniformType, &err);
+			bx::write(_shaderWriter, un.num, &err);
+			bx::write(_shaderWriter, un.regIndex, &err);
+			bx::write(_shaderWriter, un.regCount, &err);
+			bx::write(_shaderWriter, un.texComponent, &err);
+			bx::write(_shaderWriter, un.texDimension, &err);
+			bx::write(_shaderWriter, un.texFormat, &err);
+
+			BX_TRACE("%s, %s, %d, %d, %d"
+				, un.name.c_str()
+				, shaderc_getUniformTypeName(un.type)
+				, un.num
+				, un.regIndex
+				, un.regCount
+				);
+		}
+
+		uint32_t shaderSize = (uint32_t)bx::strLen(optimizedShader);
+		bx::write(_shaderWriter, shaderSize, &err);
+		bx::write(_shaderWriter, optimizedShader, shaderSize, &err);
+		uint8_t nul = 0;
+		bx::write(_shaderWriter, nul, &err);
+
+		if (_options.disasm )
+		{
+			std::string disasmfp = _options.outputFilePath + ".disasm";
+			writeFile(disasmfp.c_str(), optimizedShader, shaderSize);
+		}
+
+		glslopt_shader_delete(shader);
+		glslopt_cleanup(ctx);
+
+		return true;
+	}
+
+} // namespace glsl
+
+	bool compileGLSLShader(const Options& _options, uint32_t _version, const std::string& _code, bx::WriterI* _shaderWriter, bx::WriterI* _messageWriter)
+	{
+		return glsl::compile(_options, _version, _code, _shaderWriter, _messageWriter);
+	}
+
+} // namespace bgfx
diff --git a/brtshaderc/shaderc_hlsl.cpp b/brtshaderc/shaderc_hlsl.cpp
new file mode 100644
index 0000000..d7e2412
--- /dev/null
+++ b/brtshaderc/shaderc_hlsl.cpp
@@ -0,0 +1,864 @@
+/*
+ * Copyright 2011-2025 Branimir Karadzic. All rights reserved.
+ * License: https://github.com/bkaradzic/bgfx/blob/master/LICENSE
+ */
+
+#include "shaderc.h"
+
+#if SHADERC_CONFIG_HLSL
+
+#if defined(__MINGW32__)
+#	define __REQUIRED_RPCNDR_H_VERSION__ 475
+#	define __in
+#	define __out
+#endif // defined(__MINGW32__)
+
+#define COM_NO_WINDOWS_H
+#include <d3dcompiler.h>
+#include <d3d11shader.h>
+#include <bx/os.h>
+
+#ifndef D3D_SVF_USED
+#	define D3D_SVF_USED 2
+#endif // D3D_SVF_USED
+
+namespace bgfx { namespace hlsl
+{
+	typedef HRESULT(WINAPI* PFN_D3D_COMPILE)(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData
+		, _In_ SIZE_T SrcDataSize
+		, _In_opt_ LPCSTR pSourceName
+		, _In_reads_opt_(_Inexpressible_(pDefines->Name != NULL) ) CONST D3D_SHADER_MACRO* pDefines
+		, _In_opt_ ID3DInclude* pInclude
+		, _In_opt_ LPCSTR pEntrypoint
+		, _In_ LPCSTR pTarget
+		, _In_ UINT Flags1
+		, _In_ UINT Flags2
+		, _Out_ ID3DBlob** ppCode
+		, _Always_(_Outptr_opt_result_maybenull_) ID3DBlob** ppErrorMsgs
+		);
+
+	typedef HRESULT(WINAPI* PFN_D3D_DISASSEMBLE)(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData
+		, _In_ SIZE_T SrcDataSize
+		, _In_ UINT Flags
+		, _In_opt_ LPCSTR szComments
+		, _Out_ ID3DBlob** ppDisassembly
+		);
+
+	typedef HRESULT(WINAPI* PFN_D3D_REFLECT)(_In_reads_bytes_(SrcDataSize) LPCVOID pSrcData
+		, _In_ SIZE_T SrcDataSize
+		, _In_ REFIID pInterface
+		, _Out_ void** ppReflector
+		);
+
+	typedef HRESULT(WINAPI* PFN_D3D_STRIP_SHADER)(_In_reads_bytes_(BytecodeLength) LPCVOID pShaderBytecode
+		, _In_ SIZE_T BytecodeLength
+		, _In_ UINT uStripFlags
+		, _Out_ ID3DBlob** ppStrippedBlob
+		);
+
+	PFN_D3D_COMPILE      D3DCompile;
+	PFN_D3D_DISASSEMBLE  D3DDisassemble;
+	PFN_D3D_REFLECT      D3DReflect;
+	PFN_D3D_STRIP_SHADER D3DStripShader;
+
+	struct D3DCompiler
+	{
+		const char* fileName;
+		const GUID  IID_ID3D11ShaderReflection;
+	};
+
+	static const D3DCompiler s_d3dcompiler[] =
+	{ // BK - the only different method in interface is GetRequiresFlags at the end
+	  //      of IID_ID3D11ShaderReflection47 (which is not used anyway).
+		{ "D3DCompiler_47.dll", { 0x8d536ca1, 0x0cca, 0x4956, { 0xa8, 0x37, 0x78, 0x69, 0x63, 0x75, 0x55, 0x84 } } },
+		{ "D3DCompiler_46.dll", { 0x0a233719, 0x3960, 0x4578, { 0x9d, 0x7c, 0x20, 0x3b, 0x8b, 0x1d, 0x9c, 0xc1 } } },
+		{ "D3DCompiler_45.dll", { 0x0a233719, 0x3960, 0x4578, { 0x9d, 0x7c, 0x20, 0x3b, 0x8b, 0x1d, 0x9c, 0xc1 } } },
+		{ "D3DCompiler_44.dll", { 0x0a233719, 0x3960, 0x4578, { 0x9d, 0x7c, 0x20, 0x3b, 0x8b, 0x1d, 0x9c, 0xc1 } } },
+		{ "D3DCompiler_43.dll", { 0x0a233719, 0x3960, 0x4578, { 0x9d, 0x7c, 0x20, 0x3b, 0x8b, 0x1d, 0x9c, 0xc1 } } },
+	};
+
+	static const D3DCompiler* s_compiler;
+	static void* s_d3dcompilerdll;
+
+	const D3DCompiler* load(bx::WriterI* _messageWriter)
+	{
+		bx::Error messageErr;
+
+		for (uint32_t ii = 0; ii < BX_COUNTOF(s_d3dcompiler); ++ii)
+		{
+			const D3DCompiler* compiler = &s_d3dcompiler[ii];
+			s_d3dcompilerdll = bx::dlopen(compiler->fileName);
+			if (NULL == s_d3dcompilerdll)
+			{
+				continue;
+			}
+
+			D3DCompile     = (PFN_D3D_COMPILE     )bx::dlsym(s_d3dcompilerdll, "D3DCompile");
+			D3DDisassemble = (PFN_D3D_DISASSEMBLE )bx::dlsym(s_d3dcompilerdll, "D3DDisassemble");
+			D3DReflect     = (PFN_D3D_REFLECT     )bx::dlsym(s_d3dcompilerdll, "D3DReflect");
+			D3DStripShader = (PFN_D3D_STRIP_SHADER)bx::dlsym(s_d3dcompilerdll, "D3DStripShader");
+
+			if (NULL == D3DCompile
+			||  NULL == D3DDisassemble
+			||  NULL == D3DReflect
+			||  NULL == D3DStripShader)
+			{
+				bx::dlclose(s_d3dcompilerdll);
+				continue;
+			}
+
+			if (g_verbose)
+			{
+				char filePath[bx::kMaxFilePath];
+				GetModuleFileNameA( (HMODULE)s_d3dcompilerdll, filePath, sizeof(filePath) );
+				BX_TRACE("Loaded %s compiler (%s).", compiler->fileName, filePath);
+			}
+
+			return compiler;
+		}
+
+		bx::write(_messageWriter, &messageErr, "Error: Unable to open D3DCompiler_*.dll shader compiler.\n");
+		return NULL;
+	}
+
+	void unload()
+	{
+		bx::dlclose(s_d3dcompilerdll);
+	}
+
+	struct CTHeader
+	{
+		uint32_t Size;
+		uint32_t Creator;
+		uint32_t Version;
+		uint32_t Constants;
+		uint32_t ConstantInfo;
+		uint32_t Flags;
+		uint32_t Target;
+	};
+
+	struct CTInfo
+	{
+		uint32_t Name;
+		uint16_t RegisterSet;
+		uint16_t RegisterIndex;
+		uint16_t RegisterCount;
+		uint16_t Reserved;
+		uint32_t TypeInfo;
+		uint32_t DefaultValue;
+	};
+
+	struct CTType
+	{
+		uint16_t Class;
+		uint16_t Type;
+		uint16_t Rows;
+		uint16_t Columns;
+		uint16_t Elements;
+		uint16_t StructMembers;
+		uint32_t StructMemberInfo;
+	};
+
+	struct RemapInputSemantic
+	{
+		bgfx::Attrib::Enum m_attr;
+		const char* m_name;
+		uint8_t m_index;
+	};
+
+	static const RemapInputSemantic s_remapInputSemantic[bgfx::Attrib::Count + 1] =
+	{
+		{ bgfx::Attrib::Position,  "POSITION",     0 },
+		{ bgfx::Attrib::Normal,    "NORMAL",       0 },
+		{ bgfx::Attrib::Tangent,   "TANGENT",      0 },
+		{ bgfx::Attrib::Bitangent, "BITANGENT",    0 },
+		{ bgfx::Attrib::Color0,    "COLOR",        0 },
+		{ bgfx::Attrib::Color1,    "COLOR",        1 },
+		{ bgfx::Attrib::Color2,    "COLOR",        2 },
+		{ bgfx::Attrib::Color3,    "COLOR",        3 },
+		{ bgfx::Attrib::Indices,   "BLENDINDICES", 0 },
+		{ bgfx::Attrib::Weight,    "BLENDWEIGHT",  0 },
+		{ bgfx::Attrib::TexCoord0, "TEXCOORD",     0 },
+		{ bgfx::Attrib::TexCoord1, "TEXCOORD",     1 },
+		{ bgfx::Attrib::TexCoord2, "TEXCOORD",     2 },
+		{ bgfx::Attrib::TexCoord3, "TEXCOORD",     3 },
+		{ bgfx::Attrib::TexCoord4, "TEXCOORD",     4 },
+		{ bgfx::Attrib::TexCoord5, "TEXCOORD",     5 },
+		{ bgfx::Attrib::TexCoord6, "TEXCOORD",     6 },
+		{ bgfx::Attrib::TexCoord7, "TEXCOORD",     7 },
+		{ bgfx::Attrib::Count,     "",             0 },
+	};
+
+	const RemapInputSemantic& findInputSemantic(const char* _name, uint8_t _index)
+	{
+		for (uint32_t ii = 0; ii < bgfx::Attrib::Count; ++ii)
+		{
+			const RemapInputSemantic& ris = s_remapInputSemantic[ii];
+			if (0 == bx::strCmp(ris.m_name, _name)
+			&&  ris.m_index == _index)
+			{
+				return ris;
+			}
+		}
+
+		return s_remapInputSemantic[bgfx::Attrib::Count];
+	}
+
+	struct UniformRemap
+	{
+		UniformType::Enum id;
+		D3D_SHADER_VARIABLE_CLASS paramClass;
+		D3D_SHADER_VARIABLE_TYPE paramType;
+		uint8_t columns;
+		uint8_t rows;
+	};
+
+	static const UniformRemap s_uniformRemap[] =
+	{
+		{ UniformType::Sampler, D3D_SVC_SCALAR,         D3D_SVT_INT,         0, 0 },
+		{ UniformType::Vec4, D3D_SVC_VECTOR,         D3D_SVT_FLOAT,       0, 0 },
+		{ UniformType::Mat3, D3D_SVC_MATRIX_COLUMNS, D3D_SVT_FLOAT,       3, 3 },
+		{ UniformType::Mat4, D3D_SVC_MATRIX_COLUMNS, D3D_SVT_FLOAT,       4, 4 },
+		{ UniformType::Sampler, D3D_SVC_OBJECT,         D3D_SVT_SAMPLER,     0, 0 },
+		{ UniformType::Sampler, D3D_SVC_OBJECT,         D3D_SVT_SAMPLER2D,   0, 0 },
+		{ UniformType::Sampler, D3D_SVC_OBJECT,         D3D_SVT_SAMPLER3D,   0, 0 },
+		{ UniformType::Sampler, D3D_SVC_OBJECT,         D3D_SVT_SAMPLERCUBE, 0, 0 },
+	};
+
+	UniformType::Enum findUniformType(const D3D11_SHADER_TYPE_DESC& constDesc)
+	{
+		for (uint32_t ii = 0; ii < BX_COUNTOF(s_uniformRemap); ++ii)
+		{
+			const UniformRemap& remap = s_uniformRemap[ii];
+
+			if (remap.paramClass == constDesc.Class
+			&&  remap.paramType == constDesc.Type)
+			{
+				if (D3D_SVC_MATRIX_COLUMNS != constDesc.Class)
+				{
+					return remap.id;
+				}
+
+				if (remap.columns == constDesc.Columns
+				&&  remap.rows == constDesc.Rows)
+				{
+					return remap.id;
+				}
+			}
+		}
+
+		return UniformType::Count;
+	}
+
+	static uint32_t s_optimizationLevelD3D11[4] =
+	{
+		D3DCOMPILE_OPTIMIZATION_LEVEL0,
+		D3DCOMPILE_OPTIMIZATION_LEVEL1,
+		D3DCOMPILE_OPTIMIZATION_LEVEL2,
+		D3DCOMPILE_OPTIMIZATION_LEVEL3,
+	};
+
+	typedef std::vector<std::string> UniformNameList;
+
+	static bool isSampler(D3D_SHADER_VARIABLE_TYPE _svt)
+	{
+		switch (_svt)
+		{
+		case D3D_SVT_SAMPLER:
+		case D3D_SVT_SAMPLER1D:
+		case D3D_SVT_SAMPLER2D:
+		case D3D_SVT_SAMPLER3D:
+		case D3D_SVT_SAMPLERCUBE:
+			return true;
+
+		default:
+			break;
+		}
+
+		return false;
+	}
+
+	bool getReflectionDataD3D9(ID3DBlob* _code, UniformArray& _uniforms, bx::WriterI* _messageWriter)
+	{
+		bx::ErrorAssert messageErr;
+
+		// see reference for magic values: https://msdn.microsoft.com/en-us/library/ff552891(VS.85).aspx
+		const uint32_t D3DSIO_COMMENT = 0x0000FFFE;
+		const uint32_t D3DSIO_END = 0x0000FFFF;
+		const uint32_t D3DSI_OPCODE_MASK = 0x0000FFFF;
+		const uint32_t D3DSI_COMMENTSIZE_MASK = 0x7FFF0000;
+		const uint32_t CTAB_CONSTANT = BX_MAKEFOURCC('C', 'T', 'A', 'B');
+
+		// parse the shader blob for the constant table
+		const size_t codeSize = _code->GetBufferSize();
+		const uint32_t* ptr = (const uint32_t*)_code->GetBufferPointer();
+		const uint32_t* end = (const uint32_t*)( (const uint8_t*)ptr + codeSize);
+		const CTHeader* header = NULL;
+
+		ptr++;	// first byte is shader type / version; skip it since we already know
+
+		while (ptr < end && *ptr != D3DSIO_END)
+		{
+			uint32_t cur = *ptr++;
+			if ( (cur & D3DSI_OPCODE_MASK) != D3DSIO_COMMENT)
+			{
+				continue;
+			}
+
+			// try to find CTAB comment block
+			uint32_t commentSize = (cur & D3DSI_COMMENTSIZE_MASK) >> 16;
+			uint32_t fourcc = *ptr;
+			if (fourcc == CTAB_CONSTANT)
+			{
+				// found the constant table data
+				header = (const CTHeader*)(ptr + 1);
+				uint32_t tableSize = (commentSize - 1) * 4;
+				if (tableSize < sizeof(CTHeader) || header->Size != sizeof(CTHeader) )
+				{
+					bx::write(_messageWriter, &messageErr, "Error: Invalid constant table data\n");
+					return false;
+				}
+				break;
+			}
+
+			// this is a different kind of comment section, so skip over it
+			ptr += commentSize - 1;
+		}
+
+		if (!header)
+		{
+			bx::write(_messageWriter, &messageErr, "Error: Could not find constant table data\n");
+			return false;
+		}
+
+		const uint8_t* headerBytePtr = (const uint8_t*)header;
+		const char* creator = (const char*)(headerBytePtr + header->Creator);
+		BX_UNUSED(creator);
+
+		BX_TRACE("Creator: %s 0x%08x", creator, header->Version);
+		BX_TRACE("Num constants: %d", header->Constants);
+		BX_TRACE("#   cl ty RxC   S  By Name");
+
+		const CTInfo* ctInfoArray = (const CTInfo*)(headerBytePtr + header->ConstantInfo);
+		for (uint32_t ii = 0; ii < header->Constants; ++ii)
+		{
+			const CTInfo& ctInfo = ctInfoArray[ii];
+			const CTType& ctType = *(const CTType*)(headerBytePtr + ctInfo.TypeInfo);
+			const char* name = (const char*)(headerBytePtr + ctInfo.Name);
+
+			BX_TRACE("%3d %2d %2d [%dx%d] %d %s[%d] c%d (%d)"
+				, ii
+				, ctType.Class
+				, ctType.Type
+				, ctType.Rows
+				, ctType.Columns
+				, ctType.StructMembers
+				, name
+				, ctType.Elements
+				, ctInfo.RegisterIndex
+				, ctInfo.RegisterCount
+				);
+
+			D3D11_SHADER_TYPE_DESC desc;
+			desc.Class = (D3D_SHADER_VARIABLE_CLASS)ctType.Class;
+			desc.Type = (D3D_SHADER_VARIABLE_TYPE)ctType.Type;
+			desc.Rows = ctType.Rows;
+			desc.Columns = ctType.Columns;
+
+			UniformType::Enum type = findUniformType(desc);
+			if (UniformType::Count != type)
+			{
+				Uniform un;
+				un.name = '$' == name[0] ? name + 1 : name;
+				un.type = isSampler(desc.Type)
+					? UniformType::Enum(kUniformSamplerBit | type)
+					: type
+					;
+				un.num = (uint8_t)ctType.Elements;
+				un.regIndex = ctInfo.RegisterIndex;
+				un.regCount = ctInfo.RegisterCount;
+
+				_uniforms.push_back(un);
+			}
+		}
+
+		return true;
+	}
+
+	bool getReflectionDataD3D11(ID3DBlob* _code, bool _vshader, UniformArray& _uniforms, uint8_t& _numAttrs, uint16_t* _attrs, uint16_t& _size, UniformNameList& unusedUniforms, bx::WriterI* _messageWriter)
+	{
+		bx::Error messageErr;
+
+		ID3D11ShaderReflection* reflect = NULL;
+		HRESULT hr = D3DReflect(_code->GetBufferPointer()
+			, _code->GetBufferSize()
+			, s_compiler->IID_ID3D11ShaderReflection
+			, (void**)&reflect
+			);
+		if (FAILED(hr) )
+		{
+			bx::write(_messageWriter, &messageErr, "Error: D3DReflect failed 0x%08x\n", (uint32_t)hr);
+			return false;
+		}
+
+		D3D11_SHADER_DESC desc;
+		hr = reflect->GetDesc(&desc);
+		if (FAILED(hr) )
+		{
+			bx::write(_messageWriter, &messageErr, "Error: ID3D11ShaderReflection::GetDesc failed 0x%08x\n", (uint32_t)hr);
+			return false;
+		}
+
+		BX_TRACE("Creator: %s 0x%08x", desc.Creator, desc.Version);
+		BX_TRACE("Num constant buffers: %d", desc.ConstantBuffers);
+
+		BX_TRACE("Input:");
+
+		if (_vshader) // Only care about input semantic on vertex shaders
+		{
+			for (uint32_t ii = 0; ii < desc.InputParameters; ++ii)
+			{
+				D3D11_SIGNATURE_PARAMETER_DESC spd;
+				reflect->GetInputParameterDesc(ii, &spd);
+				BX_TRACE("\t%2d: %s%d, vt %d, ct %d, mask %x, reg %d"
+					, ii
+					, spd.SemanticName
+					, spd.SemanticIndex
+					, spd.SystemValueType
+					, spd.ComponentType
+					, spd.Mask
+					, spd.Register
+					);
+
+				const RemapInputSemantic& ris = findInputSemantic(spd.SemanticName, uint8_t(spd.SemanticIndex) );
+				if (ris.m_attr != bgfx::Attrib::Count)
+				{
+					_attrs[_numAttrs] = bgfx::attribToId(ris.m_attr);
+					++_numAttrs;
+				}
+			}
+		}
+
+		BX_TRACE("Output:");
+		for (uint32_t ii = 0; ii < desc.OutputParameters; ++ii)
+		{
+			D3D11_SIGNATURE_PARAMETER_DESC spd;
+			reflect->GetOutputParameterDesc(ii, &spd);
+			BX_TRACE("\t%2d: %s%d, %d, %d", ii, spd.SemanticName, spd.SemanticIndex, spd.SystemValueType, spd.ComponentType);
+		}
+
+		for (uint32_t ii = 0, num = bx::uint32_min(1, desc.ConstantBuffers); ii < num; ++ii)
+		{
+			ID3D11ShaderReflectionConstantBuffer* cbuffer = reflect->GetConstantBufferByIndex(ii);
+			D3D11_SHADER_BUFFER_DESC bufferDesc;
+			hr = cbuffer->GetDesc(&bufferDesc);
+
+			_size = (uint16_t)bufferDesc.Size;
+
+			if (SUCCEEDED(hr) )
+			{
+				BX_TRACE("%s, %d, vars %d, size %d"
+					, bufferDesc.Name
+					, bufferDesc.Type
+					, bufferDesc.Variables
+					, bufferDesc.Size
+					);
+
+				for (uint32_t jj = 0; jj < bufferDesc.Variables; ++jj)
+				{
+					ID3D11ShaderReflectionVariable* var = cbuffer->GetVariableByIndex(jj);
+					ID3D11ShaderReflectionType* type = var->GetType();
+					D3D11_SHADER_VARIABLE_DESC varDesc;
+					hr = var->GetDesc(&varDesc);
+					if (SUCCEEDED(hr) )
+					{
+						D3D11_SHADER_TYPE_DESC constDesc;
+						hr = type->GetDesc(&constDesc);
+						if (SUCCEEDED(hr) )
+						{
+							UniformType::Enum uniformType = findUniformType(constDesc);
+
+							if (UniformType::Count != uniformType
+							&&  0 != (varDesc.uFlags & D3D_SVF_USED) )
+							{
+								Uniform un;
+								un.name = varDesc.Name;
+								un.type = uniformType;
+								un.num = uint8_t(constDesc.Elements);
+								un.regIndex = uint16_t(varDesc.StartOffset);
+								un.regCount = uint16_t(bx::alignUp(varDesc.Size, 16) / 16);
+								_uniforms.push_back(un);
+
+								BX_TRACE("\t%s, %d, size %d, flags 0x%08x, %d (used)"
+									, varDesc.Name
+									, varDesc.StartOffset
+									, varDesc.Size
+									, varDesc.uFlags
+									, uniformType
+									);
+							}
+							else
+							{
+								if (0 == (varDesc.uFlags & D3D_SVF_USED) )
+								{
+									unusedUniforms.push_back(varDesc.Name);
+								}
+
+								BX_TRACE("\t%s, unknown type", varDesc.Name);
+							}
+						}
+					}
+				}
+			}
+		}
+
+		BX_TRACE("Bound:");
+		for (uint32_t ii = 0; ii < desc.BoundResources; ++ii)
+		{
+			D3D11_SHADER_INPUT_BIND_DESC bindDesc;
+
+			hr = reflect->GetResourceBindingDesc(ii, &bindDesc);
+			if (SUCCEEDED(hr) )
+			{
+				if (D3D_SIT_SAMPLER == bindDesc.Type || D3D_SIT_TEXTURE == bindDesc.Type)
+				{
+					BX_TRACE("\t%s, %d, %d, %d"
+						, bindDesc.Name
+						, bindDesc.Type
+						, bindDesc.BindPoint
+						, bindDesc.BindCount
+						);
+
+					bx::StringView end = bx::strFind(bindDesc.Name, "Sampler");
+					if (end.isEmpty())
+						end = bx::strFind(bindDesc.Name, "Texture");
+
+					if (!end.isEmpty() )
+					{
+						Uniform un;
+						un.name.assign(bindDesc.Name, (end.getPtr() - bindDesc.Name) );
+						un.type = UniformType::Enum(kUniformSamplerBit | UniformType::Sampler);
+						un.num = 1;
+						un.regIndex = uint16_t(bindDesc.BindPoint);
+						un.regCount = uint16_t(bindDesc.BindCount);
+						_uniforms.push_back(un);
+					}
+				}
+				else
+				{
+					BX_TRACE("\t%s, unknown bind data", bindDesc.Name);
+				}
+			}
+		}
+
+		if (NULL != reflect)
+		{
+			reflect->Release();
+		}
+
+		return true;
+	}
+
+	static bool compile(const Options& _options, uint32_t _version, const std::string& _code, bx::WriterI* _shaderWriter, bx::WriterI* _messageWriter, bool _firstPass)
+	{
+		bx::Error messageErr;
+
+		const char* profile = _options.profile.c_str();
+
+		if (profile[0] == '\0')
+		{
+			bx::write(_messageWriter, &messageErr, "Error: Shader profile must be specified.\n");
+			return false;
+		}
+
+		char profileAndType[8] = {};
+		profileAndType[0] = (_options.shaderType == 'f') ? 'p' : _options.shaderType;
+		bx::strCat(profileAndType, BX_COUNTOF(profileAndType), profile);
+
+		s_compiler = load(_messageWriter);
+
+		bool result = false;
+		bool debug = _options.debugInformation;
+
+		uint32_t flags = D3DCOMPILE_ENABLE_BACKWARDS_COMPATIBILITY;
+		flags |= debug ? D3DCOMPILE_DEBUG : 0;
+		flags |= _options.avoidFlowControl ? D3DCOMPILE_AVOID_FLOW_CONTROL : 0;
+		flags |= _options.noPreshader ? D3DCOMPILE_NO_PRESHADER : 0;
+		flags |= _options.partialPrecision ? D3DCOMPILE_PARTIAL_PRECISION : 0;
+		flags |= _options.preferFlowControl ? D3DCOMPILE_PREFER_FLOW_CONTROL : 0;
+		flags |= _options.backwardsCompatibility ? D3DCOMPILE_ENABLE_BACKWARDS_COMPATIBILITY : 0;
+
+		bool werror = _options.warningsAreErrors;
+
+		if (werror)
+		{
+			flags |= D3DCOMPILE_WARNINGS_ARE_ERRORS;
+		}
+
+		if (_options.optimize )
+		{
+			uint32_t optimization = bx::uint32_min(_options.optimizationLevel, BX_COUNTOF(s_optimizationLevelD3D11) - 1);
+			flags |= s_optimizationLevelD3D11[optimization];
+		}
+		else
+		{
+			flags |= D3DCOMPILE_SKIP_OPTIMIZATION;
+		}
+
+		BX_TRACE("Profile: %s", profile);
+		BX_TRACE("Flags: 0x%08x", flags);
+
+		ID3DBlob* code;
+		ID3DBlob* errorMsg;
+
+		// Output preprocessed shader so that HLSL can be debugged via GPA
+		// or PIX. Compiling through memory won't embed preprocessed shader
+		// file path.
+		std::string hlslfp;
+
+		if (debug)
+		{
+			hlslfp = _options.outputFilePath + ".hlsl";
+			writeFile(hlslfp.c_str(), _code.c_str(), (int32_t)_code.size() );
+		}
+
+		bx::ErrorAssert err;
+
+		HRESULT hr = D3DCompile(_code.c_str()
+			, _code.size()
+			, hlslfp.c_str()
+			, NULL
+			, NULL
+			, "main"
+			, profileAndType
+			, flags
+			, 0
+			, &code
+			, &errorMsg
+			);
+		if (FAILED(hr)
+		|| (werror && NULL != errorMsg) )
+		{
+			const char* log = (char*)errorMsg->GetBufferPointer();
+
+			int32_t line   = 0;
+			int32_t column = 0;
+			int32_t start  = 0;
+			int32_t end    = INT32_MAX;
+
+			if (!hlslfp.empty())
+			{
+				bx::StringView logfp = bx::strFind(log, hlslfp.c_str() );
+				if (!logfp.isEmpty() )
+				{
+					log = logfp.getPtr() + hlslfp.length();
+				}
+			}
+
+			bool found = false
+				|| 2 == sscanf(log, "(%u,%u",  &line, &column)
+				|| 2 == sscanf(log, " :%u:%u: ", &line, &column)
+				;
+
+			if (found
+			&&  0 != line)
+			{
+				start = bx::uint32_imax(1, line - 10);
+				end   = start + 20;
+			}
+
+			printCode(_code.c_str(), line, start, end, column);
+			bx::write(_messageWriter, &messageErr, "Error: D3DCompile failed 0x%08x %s\n", (uint32_t)hr, log);
+			errorMsg->Release();
+			return false;
+		}
+
+		UniformArray uniforms;
+		uint8_t numAttrs = 0;
+		uint16_t attrs[bgfx::Attrib::Count];
+		uint16_t size = 0;
+
+		if (_version < 400)
+		{
+			if (!getReflectionDataD3D9(code, uniforms, _messageWriter) )
+			{
+				bx::write(_messageWriter, &messageErr, "Error: Unable to get D3D9 reflection data.\n");
+				goto error;
+			}
+		}
+		else
+		{
+			UniformNameList unusedUniforms;
+			if (!getReflectionDataD3D11(code, profileAndType[0] == 'v', uniforms, numAttrs, attrs, size, unusedUniforms, _messageWriter) )
+			{
+				bx::write(_messageWriter, &messageErr, "Error: Unable to get D3D11 reflection data.\n");
+				goto error;
+			}
+
+			if (_firstPass
+			&&  unusedUniforms.size() > 0)
+			{
+				// first time through, we just find unused uniforms and get rid of them
+				std::string output;
+				bx::LineReader reader(_code.c_str() );
+				while (!reader.isDone() )
+				{
+					bx::StringView strLine = reader.next();
+					bool found = false;
+
+					for (UniformNameList::iterator it = unusedUniforms.begin(), itEnd = unusedUniforms.end(); it != itEnd; ++it)
+					{
+						bx::StringView str = strFind(strLine, "uniform ");
+						if (str.isEmpty() )
+						{
+							continue;
+						}
+
+						// matching lines like:  uniform u_name;
+						// we want to replace "uniform" with "static" so that it's no longer
+						// included in the uniform blob that the application must upload
+						// we can't just remove them, because unused functions might still reference
+						// them and cause a compile error when they're gone
+						if (!bx::findIdentifierMatch(strLine, it->c_str() ).isEmpty() )
+						{
+							output.append(strLine.getPtr(), str.getPtr() );
+							output += "static ";
+							output.append(str.getTerm(), strLine.getTerm() );
+							output += "\n";
+							found = true;
+
+							unusedUniforms.erase(it);
+							break;
+						}
+					}
+
+					if (!found)
+					{
+						output.append(strLine.getPtr(), strLine.getTerm() );
+						output += "\n";
+					}
+				}
+
+				// recompile with the unused uniforms converted to statics
+				return compile(_options, _version, output.c_str(), _shaderWriter, _messageWriter, false);
+			}
+		}
+
+		{
+			uint16_t count = (uint16_t)uniforms.size();
+			bx::write(_shaderWriter, count, &err);
+
+			uint32_t fragmentBit = profileAndType[0] == 'p' ? kUniformFragmentBit : 0;
+			for (UniformArray::const_iterator it = uniforms.begin(); it != uniforms.end(); ++it)
+			{
+				const Uniform& un = *it;
+				uint8_t nameSize = (uint8_t)un.name.size();
+				bx::write(_shaderWriter, nameSize, &err);
+				bx::write(_shaderWriter, un.name.c_str(), nameSize, &err);
+				uint8_t type = uint8_t(un.type | fragmentBit);
+				bx::write(_shaderWriter, type, &err);
+				bx::write(_shaderWriter, un.num, &err);
+				bx::write(_shaderWriter, un.regIndex, &err);
+				bx::write(_shaderWriter, un.regCount, &err);
+				bx::write(_shaderWriter, un.texComponent, &err);
+				bx::write(_shaderWriter, un.texDimension, &err);
+				bx::write(_shaderWriter, un.texFormat, &err);
+
+				BX_TRACE("%s, %s, %d, %d, %d"
+					, un.name.c_str()
+					, shaderc_getUniformTypeName(UniformType::Enum(un.type & ~kUniformMask))
+					, un.num
+					, un.regIndex
+					, un.regCount
+					);
+			}
+		}
+
+		{
+			ID3DBlob* stripped;
+			hr = D3DStripShader(code->GetBufferPointer()
+				, code->GetBufferSize()
+				, D3DCOMPILER_STRIP_REFLECTION_DATA
+				| D3DCOMPILER_STRIP_TEST_BLOBS
+				, &stripped
+				);
+
+			if (SUCCEEDED(hr) )
+			{
+				code->Release();
+				code = stripped;
+			}
+		}
+
+		{
+			uint32_t shaderSize = uint32_t(code->GetBufferSize() );
+			bx::write(_shaderWriter, shaderSize, &err);
+			bx::write(_shaderWriter, code->GetBufferPointer(), shaderSize, &err);
+			uint8_t nul = 0;
+			bx::write(_shaderWriter, nul, &err);
+		}
+
+		if (_version >= 400)
+		{
+			bx::write(_shaderWriter, numAttrs, &err);
+			bx::write(_shaderWriter, attrs, numAttrs*sizeof(uint16_t), &err);
+
+			bx::write(_shaderWriter, size, &err);
+		}
+
+		if (_options.disasm )
+		{
+			ID3DBlob* disasm;
+			D3DDisassemble(code->GetBufferPointer()
+				, code->GetBufferSize()
+				, 0
+				, NULL
+				, &disasm
+				);
+
+			if (NULL != disasm)
+			{
+				std::string disasmfp = _options.outputFilePath + ".disasm";
+
+				writeFile(disasmfp.c_str(), disasm->GetBufferPointer(), (uint32_t)disasm->GetBufferSize() );
+				disasm->Release();
+			}
+		}
+
+		if (NULL != errorMsg)
+		{
+			errorMsg->Release();
+		}
+
+		result = true;
+
+	error:
+		code->Release();
+		unload();
+		return result;
+	}
+
+} // namespace hlsl
+
+	bool compileHLSLShader(const Options& _options, uint32_t _version, const std::string& _code, bx::WriterI* _shaderWriter, bx::WriterI* _messageWriter)
+	{
+		return hlsl::compile(_options, _version, _code, _shaderWriter, _messageWriter, true);
+	}
+
+} // namespace bgfx
+
+#else
+
+namespace bgfx
+{
+	bool compileHLSLShader(const Options& _options, uint32_t _version, const std::string& _code, bx::WriterI* _shaderWriter, bx::WriterI* _messageWriter)
+	{
+		BX_UNUSED(_options, _version, _code, _shaderWriter);
+		bx::Error messageErr;
+		bx::write(_messageWriter, &messageErr, "HLSL compiler is not supported on this platform.\n");
+		return false;
+	}
+
+} // namespace bgfx
+
+#endif // SHADERC_CONFIG_HLSL
diff --git a/brtshaderc/shaderc_metal.cpp b/brtshaderc/shaderc_metal.cpp
new file mode 100644
index 0000000..59e48f4
--- /dev/null
+++ b/brtshaderc/shaderc_metal.cpp
@@ -0,0 +1,819 @@
+/*
+ * Copyright 2011-2025 Branimir Karadzic. All rights reserved.
+ * License: https://github.com/bkaradzic/bgfx/blob/master/LICENSE
+ */
+
+#include "shaderc.h"
+
+#include <iostream> // std::cout
+
+BX_PRAGMA_DIAGNOSTIC_PUSH()
+BX_PRAGMA_DIAGNOSTIC_IGNORED_MSVC(4100) // error C4100: 'inclusionDepth' : unreferenced formal parameter
+BX_PRAGMA_DIAGNOSTIC_IGNORED_MSVC(4265) // error C4265: 'spv::spirvbin_t': class has virtual functions, but destructor is not virtual
+BX_PRAGMA_DIAGNOSTIC_IGNORED_CLANG_GCC("-Wattributes") // warning: attribute ignored
+BX_PRAGMA_DIAGNOSTIC_IGNORED_CLANG_GCC("-Wdeprecated-declarations") // warning: ‘MSLVertexAttr’ is deprecated
+BX_PRAGMA_DIAGNOSTIC_IGNORED_CLANG_GCC("-Wtype-limits") // warning: comparison of unsigned expression in ‘< 0’ is always false
+BX_PRAGMA_DIAGNOSTIC_IGNORED_CLANG_GCC("-Wshadow") // warning: declaration of 'userData' shadows a member of 'glslang::TShader::Includer::IncludeResult'
+#define ENABLE_OPT 1
+#include <ShaderLang.h>
+#include <ResourceLimits.h>
+#include <SPIRV/GlslangToSpv.h>
+#include <SPIRV/SPVRemapper.h>
+#include <SPIRV/SpvTools.h>
+#define SPIRV_CROSS_EXCEPTIONS_TO_ASSERTIONS
+#include <spirv_msl.hpp>
+#include <spirv_reflect.hpp>
+#include <spirv-tools/optimizer.hpp>
+BX_PRAGMA_DIAGNOSTIC_POP()
+
+namespace bgfx
+{
+	struct TinyStlAllocator
+	{
+		static void* static_allocate(size_t _bytes);
+		static void static_deallocate(void* _ptr, size_t /*_bytes*/);
+	};
+
+} // namespace bgfx
+
+#define TINYSTL_ALLOCATOR bgfx::TinyStlAllocator
+#include <tinystl/allocator.h>
+#include <tinystl/string.h>
+#include <tinystl/unordered_map.h>
+#include <tinystl/vector.h>
+namespace stl = tinystl;
+
+#include "../../src/shader.h"
+
+namespace bgfx { namespace metal
+{
+	const TBuiltInResource resourceLimits =
+	{
+		32,    // MaxLights
+		6,     // MaxClipPlanes
+		32,    // MaxTextureUnits
+		32,    // MaxTextureCoords
+		64,    // MaxVertexAttribs
+		4096,  // MaxVertexUniformComponents
+		64,    // MaxVaryingFloats
+		32,    // MaxVertexTextureImageUnits
+		80,    // MaxCombinedTextureImageUnits
+		32,    // MaxTextureImageUnits
+		4096,  // MaxFragmentUniformComponents
+		32,    // MaxDrawBuffers
+		128,   // MaxVertexUniformVectors
+		8,     // MaxVaryingVectors
+		16,    // MaxFragmentUniformVectors
+		16,    // MaxVertexOutputVectors
+		15,    // MaxFragmentInputVectors
+		-8,    // MinProgramTexelOffset
+		7,     // MaxProgramTexelOffset
+		8,     // MaxClipDistances
+		65535, // MaxComputeWorkGroupCountX
+		65535, // MaxComputeWorkGroupCountY
+		65535, // MaxComputeWorkGroupCountZ
+		1024,  // MaxComputeWorkGroupSizeX
+		1024,  // MaxComputeWorkGroupSizeY
+		64,    // MaxComputeWorkGroupSizeZ
+		1024,  // MaxComputeUniformComponents
+		16,    // MaxComputeTextureImageUnits
+		8,     // MaxComputeImageUniforms
+		8,     // MaxComputeAtomicCounters
+		1,     // MaxComputeAtomicCounterBuffers
+		60,    // MaxVaryingComponents
+		64,    // MaxVertexOutputComponents
+		64,    // MaxGeometryInputComponents
+		128,   // MaxGeometryOutputComponents
+		128,   // MaxFragmentInputComponents
+		8,     // MaxImageUnits
+		8,     // MaxCombinedImageUnitsAndFragmentOutputs
+		8,     // MaxCombinedShaderOutputResources
+		0,     // MaxImageSamples
+		0,     // MaxVertexImageUniforms
+		0,     // MaxTessControlImageUniforms
+		0,     // MaxTessEvaluationImageUniforms
+		0,     // MaxGeometryImageUniforms
+		8,     // MaxFragmentImageUniforms
+		8,     // MaxCombinedImageUniforms
+		16,    // MaxGeometryTextureImageUnits
+		256,   // MaxGeometryOutputVertices
+		1024,  // MaxGeometryTotalOutputComponents
+		1024,  // MaxGeometryUniformComponents
+		64,    // MaxGeometryVaryingComponents
+		128,   // MaxTessControlInputComponents
+		128,   // MaxTessControlOutputComponents
+		16,    // MaxTessControlTextureImageUnits
+		1024,  // MaxTessControlUniformComponents
+		4096,  // MaxTessControlTotalOutputComponents
+		128,   // MaxTessEvaluationInputComponents
+		128,   // MaxTessEvaluationOutputComponents
+		16,    // MaxTessEvaluationTextureImageUnits
+		1024,  // MaxTessEvaluationUniformComponents
+		120,   // MaxTessPatchComponents
+		32,    // MaxPatchVertices
+		64,    // MaxTessGenLevel
+		16,    // MaxViewports
+		0,     // MaxVertexAtomicCounters
+		0,     // MaxTessControlAtomicCounters
+		0,     // MaxTessEvaluationAtomicCounters
+		0,     // MaxGeometryAtomicCounters
+		8,     // MaxFragmentAtomicCounters
+		8,     // MaxCombinedAtomicCounters
+		1,     // MaxAtomicCounterBindings
+		0,     // MaxVertexAtomicCounterBuffers
+		0,     // MaxTessControlAtomicCounterBuffers
+		0,     // MaxTessEvaluationAtomicCounterBuffers
+		0,     // MaxGeometryAtomicCounterBuffers
+		1,     // MaxFragmentAtomicCounterBuffers
+		1,     // MaxCombinedAtomicCounterBuffers
+		16384, // MaxAtomicCounterBufferSize
+		4,     // MaxTransformFeedbackBuffers
+		64,    // MaxTransformFeedbackInterleavedComponents
+		8,     // MaxCullDistances
+		8,     // MaxCombinedClipAndCullDistances
+		4,     // MaxSamples
+		0,     // maxMeshOutputVerticesNV
+		0,     // maxMeshOutputPrimitivesNV
+		0,     // maxMeshWorkGroupSizeX_NV
+		0,     // maxMeshWorkGroupSizeY_NV
+		0,     // maxMeshWorkGroupSizeZ_NV
+		0,     // maxTaskWorkGroupSizeX_NV
+		0,     // maxTaskWorkGroupSizeY_NV
+		0,     // maxTaskWorkGroupSizeZ_NV
+		0,     // maxMeshViewCountNV
+		0,     // maxMeshOutputVerticesEXT
+		0,     // maxMeshOutputPrimitivesEXT
+		0,     // maxMeshWorkGroupSizeX_EXT
+		0,     // maxMeshWorkGroupSizeY_EXT
+		0,     // maxMeshWorkGroupSizeZ_EXT
+		0,     // maxTaskWorkGroupSizeX_EXT
+		0,     // maxTaskWorkGroupSizeY_EXT
+		0,     // maxTaskWorkGroupSizeZ_EXT
+		0,     // maxMeshViewCountEXT
+		0,     // maxDualSourceDrawBuffersEXT
+
+		{ // limits
+			true, // nonInductiveForLoops
+			true, // whileLoops
+			true, // doWhileLoops
+			true, // generalUniformIndexing
+			true, // generalAttributeMatrixVectorIndexing
+			true, // generalVaryingIndexing
+			true, // generalSamplerIndexing
+			true, // generalVariableIndexing
+			true, // generalConstantMatrixVectorIndexing
+		},
+	};
+
+	static EShLanguage getLang(char _p)
+	{
+		switch (_p)
+		{
+		case 'c': return EShLangCompute;
+		case 'f': return EShLangFragment;
+		case 'v': return EShLangVertex;
+		default:  return EShLangCount;
+		}
+	}
+
+	static const char* s_attribName[] =
+	{
+		"a_position",
+		"a_normal",
+		"a_tangent",
+		"a_bitangent",
+		"a_color0",
+		"a_color1",
+		"a_color2",
+		"a_color3",
+		"a_indices",
+		"a_weight",
+		"a_texcoord0",
+		"a_texcoord1",
+		"a_texcoord2",
+		"a_texcoord3",
+		"a_texcoord4",
+		"a_texcoord5",
+		"a_texcoord6",
+		"a_texcoord7",
+	};
+	static_assert(bgfx::Attrib::Count == BX_COUNTOF(s_attribName) );
+
+	bgfx::Attrib::Enum toAttribEnum(const bx::StringView& _name)
+	{
+		for (uint8_t ii = 0; ii < Attrib::Count; ++ii)
+		{
+			if (0 == bx::strCmp(s_attribName[ii], _name) )
+			{
+				return bgfx::Attrib::Enum(ii);
+			}
+		}
+
+		return bgfx::Attrib::Count;
+	}
+
+	static const char* s_samplerTypes[] =
+	{
+		"BgfxSampler2D",
+		"BgfxISampler2D",
+		"BgfxUSampler2D",
+		"BgfxSampler2DArray",
+		"BgfxSampler2DShadow",
+		"BgfxSampler2DArrayShadow",
+		"BgfxSampler3D",
+		"BgfxISampler3D",
+		"BgfxUSampler3D",
+		"BgfxSamplerCube",
+		"BgfxSamplerCubeShadow",
+		"BgfxSampler2DMS",
+	};
+
+	static uint16_t writeUniformArray(bx::WriterI* _shaderWriter, const UniformArray& uniforms, bool isFragmentShader)
+	{
+		uint16_t size = 0;
+
+		bx::ErrorAssert err;
+
+		uint16_t count = uint16_t(uniforms.size());
+		bx::write(_shaderWriter, count, &err);
+
+		uint32_t fragmentBit = isFragmentShader ? kUniformFragmentBit : 0;
+		for (uint16_t ii = 0; ii < count; ++ii)
+		{
+			const Uniform& un = uniforms[ii];
+
+			size += un.regCount*16;
+
+			uint8_t nameSize = (uint8_t)un.name.size();
+			bx::write(_shaderWriter, nameSize, &err);
+			bx::write(_shaderWriter, un.name.c_str(), nameSize, &err);
+			bx::write(_shaderWriter, uint8_t(un.type | fragmentBit), &err);
+			bx::write(_shaderWriter, un.num, &err);
+			bx::write(_shaderWriter, un.regIndex, &err);
+			bx::write(_shaderWriter, un.regCount, &err);
+			bx::write(_shaderWriter, un.texComponent, &err);
+			bx::write(_shaderWriter, un.texDimension, &err);
+			bx::write(_shaderWriter, un.texFormat, &err);
+
+			BX_TRACE("%s, %s, %d, %d, %d"
+				, un.name.c_str()
+				, shaderc_getUniformTypeName(un.type)
+				, un.num
+				, un.regIndex
+				, un.regCount
+			);
+		}
+		return size;
+	}
+
+	static spv_target_env getSpirvTargetVersion(uint32_t _version, bx::WriterI* _messageWriter)
+	{
+		bx::ErrorAssert err;
+
+		switch (_version)
+		{
+		case 1000:
+		case 1110:
+		case 1210:
+			return SPV_ENV_VULKAN_1_0;
+		case 2011:
+		case 2111:
+		case 2211:
+			return SPV_ENV_VULKAN_1_1;
+		case 2314:
+		case 2414:
+		case 3014:
+		case 3114:
+			return SPV_ENV_VULKAN_1_1_SPIRV_1_4;
+		default:
+			bx::write(_messageWriter, &err, "Warning: Unknown SPIR-V version requested. Returning SPV_ENV_VULKAN_1_0 as default.\n");
+			return SPV_ENV_VULKAN_1_0;
+		}
+	}
+
+	static glslang::EShTargetLanguageVersion getGlslangTargetSpirvVersion(uint32_t _version, bx::WriterI* _messageWriter)
+	{
+		bx::ErrorAssert err;
+
+		switch (_version)
+		{
+		case 1000:
+		case 1110:
+		case 1210:
+			return glslang::EShTargetSpv_1_0;
+		case 2011:
+		case 2111:
+		case 2211:
+			return glslang::EShTargetSpv_1_1;
+		case 2314:
+		case 2414:
+		case 3014:
+		case 3114:
+			return glslang::EShTargetSpv_1_4;
+		default:
+			bx::write(_messageWriter, &err, "Warning: Unknown SPIR-V version requested. Returning EShTargetSpv_1_0 as default.\n");
+			return glslang::EShTargetSpv_1_0;
+		}
+	}
+
+	static spirv_cross::CompilerMSL::Options::Platform getMslPlatform(const std::string& _platform)
+	{
+		return "ios" == _platform
+			? spirv_cross::CompilerMSL::Options::Platform::iOS
+			: spirv_cross::CompilerMSL::Options::Platform::macOS;
+	}
+
+	static void getMSLVersion(const uint32_t _version, uint32_t& _major, uint32_t& _minor, bx::WriterI* _messageWriter)
+	{
+		bx::ErrorAssert err;
+
+		_major = _version / 1000;
+		_minor = (_version / 100) % 10;
+
+		switch (_version)
+		{
+		case 1000:
+		case 1110:
+		case 1210:
+		case 2011:
+		case 2111:
+		case 2211:
+		case 2314:
+		case 2414:
+		case 3014:
+		case 3114:
+			return;
+		default:
+			bx::write(_messageWriter, &err, "Warning: Unknown MSL version requested. Returning 1.0 as default.\n");
+			_major = 1;
+			_minor = 0;
+		}
+	}
+
+	static bool compile(const Options& _options, uint32_t _version, const std::string& _code, bx::WriterI* _shaderWriter, bx::WriterI* _messageWriter, bool _firstPass)
+	{
+		BX_UNUSED(_version);
+
+		bx::ErrorAssert messageErr;
+
+		glslang::InitializeProcess();
+
+		EShLanguage stage = getLang(_options.shaderType);
+		if (EShLangCount == stage)
+		{
+			bx::write(_messageWriter, &messageErr, "Error: Unknown shader type '%c'.\n", _options.shaderType);
+			return false;
+		}
+
+		glslang::TProgram* program = new glslang::TProgram;
+		glslang::TShader* shader   = new glslang::TShader(stage);
+
+		EShMessages messages = EShMessages(0
+			| EShMsgDefault
+			| EShMsgReadHlsl
+			| EShMsgVulkanRules
+			| EShMsgSpvRules
+			| EShMsgDebugInfo
+			);
+
+		shader->setEntryPoint("main");
+		shader->setAutoMapBindings(true);
+		shader->setEnvTarget(glslang::EShTargetSpv, getGlslangTargetSpirvVersion(_version, _messageWriter));
+		const int textureBindingOffset = 16;
+		shader->setShiftBinding(glslang::EResTexture, textureBindingOffset);
+		shader->setShiftBinding(glslang::EResSampler, textureBindingOffset);
+		shader->setShiftBinding(glslang::EResImage, textureBindingOffset);
+
+		const char* shaderStrings[] = { _code.c_str() };
+		shader->setStrings(
+			  shaderStrings
+			, BX_COUNTOF(shaderStrings)
+			);
+		bool compiled = shader->parse(&resourceLimits
+			, 110
+			, false
+			, messages
+			);
+		bool linked = false;
+		bool validated = true;
+
+		if (!compiled)
+		{
+			const char* log = shader->getInfoLog();
+			if (NULL != log)
+			{
+				int32_t source  = 0;
+				int32_t line    = 0;
+				int32_t column  = 0;
+				int32_t start   = 0;
+				int32_t end     = INT32_MAX;
+
+				bx::StringView err = bx::strFind(log, "ERROR:");
+
+				bool found = false;
+
+				if (!err.isEmpty() )
+				{
+					found = 2 == sscanf(err.getPtr(), "ERROR: %u:%u: '", &source, &line);
+					if (found)
+					{
+						++line;
+					}
+				}
+
+				if (found)
+				{
+					start = bx::uint32_imax(1, line-10);
+					end   = start + 20;
+				}
+
+				printCode(_code.c_str(), bx::uint32_satsub(line, 1), start, end, column);
+
+				bx::write(_messageWriter, &messageErr, "%s\n", log);
+			}
+		}
+		else
+		{
+			program->addShader(shader);
+			linked = true
+				&& program->link(messages)
+				&& program->mapIO()
+				;
+
+			if (!linked)
+			{
+				const char* log = program->getInfoLog();
+				if (NULL != log)
+				{
+					bx::write(_messageWriter, &messageErr, "%s\n", log);
+				}
+			}
+			else
+			{
+				program->buildReflection();
+
+				if (_firstPass)
+				{
+					// first time through, we just find unused uniforms and get rid of them
+					std::string output;
+					bx::Error err;
+					bx::LineReader reader(_code.c_str() );
+					while (!reader.isDone() )
+					{
+						bx::StringView strLine = reader.next();
+						bx::StringView str = strFind(strLine, "uniform ");
+
+						if (!str.isEmpty() )
+						{
+							// If the line declares a uniform, merge all next
+							// lines until we encounter a semicolon.
+							bx::StringView lineEnd = strFind(strLine, ";");
+							while (lineEnd.isEmpty() && !reader.isDone())
+							{
+								bx::StringView nextLine = reader.next();
+								strLine.set(strLine.getPtr(), nextLine.getTerm());
+								lineEnd = strFind(nextLine, ";");
+							}
+
+							bool found = false;
+
+							for (uint32_t ii = 0; ii < BX_COUNTOF(s_samplerTypes); ++ii)
+							{
+								if (!bx::findIdentifierMatch(strLine, s_samplerTypes[ii]).isEmpty() )
+								{
+									found = true;
+									break;
+								}
+							}
+
+							if (!found)
+							{
+								for (int32_t ii = 0, num = program->getNumLiveUniformVariables(); ii < num; ++ii)
+								{
+									// matching lines like:  uniform u_name;
+									// we want to replace "uniform" with "static" so that it's no longer
+									// included in the uniform blob that the application must upload
+									// we can't just remove them, because unused functions might still reference
+									// them and cause a compile error when they're gone
+									if (!bx::findIdentifierMatch(strLine, program->getUniformName(ii) ).isEmpty() )
+									{
+										found = true;
+										break;
+									}
+								}
+							}
+
+							if (!found)
+							{
+								output.append(strLine.getPtr(), str.getPtr() );
+								output += "static ";
+								output.append(str.getTerm(), strLine.getTerm() );
+								output += "\n";
+							}
+							else
+							{
+								output.append(strLine.getPtr(), strLine.getTerm() );
+								output += "\n";
+							}
+						}
+						else
+						{
+							output.append(strLine.getPtr(), strLine.getTerm() );
+							output += "\n";
+						}
+					}
+
+					// recompile with the unused uniforms converted to statics
+					delete program;
+					delete shader;
+					return compile(_options, _version, output.c_str(), _shaderWriter, _messageWriter, false);
+				}
+
+				UniformArray uniforms;
+
+				{
+					uint16_t count = (uint16_t)program->getNumLiveUniformVariables();
+
+					for (uint16_t ii = 0; ii < count; ++ii)
+					{
+						Uniform un;
+						un.name = program->getUniformName(ii);
+
+						if (bx::hasSuffix(un.name.c_str(), ".@data") )
+						{
+							continue;
+						}
+
+						un.num = uint8_t(program->getUniformArraySize(ii) );
+						const uint32_t offset = program->getUniformBufferOffset(ii);
+						un.regIndex = uint16_t(offset);
+						un.regCount = un.num;
+
+						switch (program->getUniformType(ii) )
+						{
+						case 0x1404: // GL_INT:
+							un.type = UniformType::Sampler;
+							break;
+						case 0x8B52: // GL_FLOAT_VEC4:
+							un.type = UniformType::Vec4;
+							break;
+						case 0x8B5B: // GL_FLOAT_MAT3:
+							un.type = UniformType::Mat3;
+							un.regCount *= 3;
+							break;
+						case 0x8B5C: // GL_FLOAT_MAT4:
+							un.type = UniformType::Mat4;
+							un.regCount *= 4;
+							break;
+						default:
+							un.type = UniformType::End;
+							break;
+						}
+
+						uniforms.push_back(un);
+					}
+				}
+				if (g_verbose)
+				{
+					program->dumpReflection();
+				}
+
+				glslang::TIntermediate* intermediate = program->getIntermediate(stage);
+				std::vector<uint32_t> spirv;
+
+				glslang::SpvOptions options;
+				options.disableOptimizer = _options.debugInformation;
+				options.generateDebugInfo = _options.debugInformation;
+				options.emitNonSemanticShaderDebugInfo = _options.debugInformation;
+				options.emitNonSemanticShaderDebugSource = _options.debugInformation;
+
+				glslang::GlslangToSpv(*intermediate, spirv, &options);
+
+				spvtools::Optimizer opt(getSpirvTargetVersion(_version, _messageWriter));
+
+				auto print_msg_to_stderr = [_messageWriter, &messageErr](
+					  spv_message_level_t
+					, const char*
+					, const spv_position_t&
+					, const char* m
+					)
+				{
+					bx::write(_messageWriter, &messageErr, "Error: %s\n", m);
+				};
+
+				opt.SetMessageConsumer(print_msg_to_stderr);
+
+				opt.RegisterLegalizationPasses();
+
+				spvtools::ValidatorOptions validatorOptions;
+				validatorOptions.SetBeforeHlslLegalization(true);
+
+				if (!opt.Run(
+					  spirv.data()
+					, spirv.size()
+					, &spirv
+					, validatorOptions
+					, false
+					) )
+				{
+					compiled = false;
+				}
+				else
+				{
+					if (g_verbose)
+					{
+						glslang::SpirvToolsDisassemble(std::cout, spirv, getSpirvTargetVersion(_version, _messageWriter));
+					}
+
+					spirv_cross::CompilerReflection refl(spirv);
+					spirv_cross::ShaderResources resourcesrefl = refl.get_shader_resources();
+
+					// Loop through the separate_images, and extract the uniform names:
+					for (auto& resource : resourcesrefl.separate_images)
+					{
+						std::string name = refl.get_name(resource.id);
+						if (name.size() > 7 && 0 == bx::strCmp(name.c_str() + name.length() - 7, "Texture"))
+						{
+							name = name.substr(0, name.length() - 7);
+						}
+
+						Uniform un;
+						un.name = name;
+						un.type = UniformType::Sampler;
+
+						un.num = 0;			// needed?
+						un.regIndex = 0;	// needed?
+						un.regCount = 0;	// needed?
+
+						uniforms.push_back(un);
+					}
+
+					uint16_t size = writeUniformArray(_shaderWriter, uniforms, _options.shaderType == 'f');
+
+					bx::Error err;
+
+					spirv_cross::CompilerMSL msl(std::move(spirv) );
+
+					// Configure MSL cross compiler
+					spirv_cross::CompilerMSL::Options mslOptions = msl.get_msl_options();
+					{
+						// - Platform
+						mslOptions.platform = getMslPlatform(_options.platform);
+
+						// - MSL Version
+						uint32_t major, minor;
+						getMSLVersion(_version, major, minor, _messageWriter);
+						mslOptions.set_msl_version(major, minor);
+					}
+					msl.set_msl_options(mslOptions);
+
+					auto executionModel = msl.get_execution_model();
+					spirv_cross::MSLResourceBinding newBinding;
+					newBinding.stage = executionModel;
+
+					spirv_cross::ShaderResources resources = msl.get_shader_resources();
+
+					spirv_cross::SmallVector<spirv_cross::EntryPoint> entryPoints = msl.get_entry_points_and_stages();
+					if (!entryPoints.empty() )
+					{
+						msl.rename_entry_point(
+							entryPoints[0].name
+							, "xlatMtlMain"
+							, entryPoints[0].execution_model
+							);
+					}
+
+					for (auto& resource : resources.uniform_buffers)
+					{
+						unsigned set     = msl.get_decoration(resource.id, spv::DecorationDescriptorSet);
+						unsigned binding = msl.get_decoration(resource.id, spv::DecorationBinding);
+						newBinding.desc_set   = set;
+						newBinding.binding    = binding;
+						newBinding.msl_buffer = 0;
+						msl.add_msl_resource_binding(newBinding);
+
+						msl.set_name(resource.id, "_mtl_u");
+					}
+
+					for (auto& resource : resources.storage_buffers)
+					{
+						unsigned set     = msl.get_decoration(resource.id, spv::DecorationDescriptorSet);
+						unsigned binding = msl.get_decoration(resource.id, spv::DecorationBinding);
+						newBinding.desc_set   = set;
+						newBinding.binding    = binding;
+						newBinding.msl_buffer = binding + 1;
+						msl.add_msl_resource_binding(newBinding);
+					}
+
+					for (auto& resource : resources.separate_samplers)
+					{
+						unsigned set     = msl.get_decoration(resource.id, spv::DecorationDescriptorSet);
+						unsigned binding = msl.get_decoration(resource.id, spv::DecorationBinding);
+						newBinding.desc_set    = set;
+						newBinding.binding     = binding;
+						newBinding.msl_texture = binding - textureBindingOffset;
+						newBinding.msl_sampler = binding - textureBindingOffset;
+						msl.add_msl_resource_binding(newBinding);
+					}
+
+					for (auto& resource : resources.separate_images)
+					{
+						std::string name = msl.get_name(resource.id);
+						if (name.size() > 7 && 0 == bx::strCmp(name.c_str() + name.length() - 7, "Texture") )
+						{
+							msl.set_name(resource.id, name.substr(0, name.length() - 7) );
+						}
+
+						unsigned set     = msl.get_decoration(resource.id, spv::DecorationDescriptorSet);
+						unsigned binding = msl.get_decoration(resource.id, spv::DecorationBinding);
+						newBinding.desc_set    = set;
+						newBinding.binding     = binding;
+						newBinding.msl_texture = binding - textureBindingOffset;
+						newBinding.msl_sampler = binding - textureBindingOffset;
+						msl.add_msl_resource_binding(newBinding);
+					}
+
+					for (auto& resource : resources.storage_images)
+					{
+						std::string name = msl.get_name(resource.id);
+
+						unsigned set     = msl.get_decoration(resource.id, spv::DecorationDescriptorSet);
+						unsigned binding = msl.get_decoration(resource.id, spv::DecorationBinding);
+						newBinding.desc_set    = set;
+						newBinding.binding     = binding;
+						newBinding.msl_texture = binding - textureBindingOffset;
+						newBinding.msl_sampler = binding - textureBindingOffset;
+						msl.add_msl_resource_binding(newBinding);
+					}
+
+					std::string source = msl.compile();
+
+					// fix https://github.com/bkaradzic/bgfx/issues/2822
+					// insert struct member which declares point size, defaulted to 1
+					if ('v' == _options.shaderType)
+					{
+						const bx::StringView xlatMtlMainOut("xlatMtlMain_out\n{");
+						size_t pos = source.find(xlatMtlMainOut.getPtr() );
+
+						if (pos != std::string::npos)
+						{
+							pos += xlatMtlMainOut.getLength();
+							source.insert(pos, "\n\tfloat bgfx_metal_pointSize [[point_size]] = 1;");
+						}
+					}
+
+					if ('c' == _options.shaderType)
+					{
+						for (int i = 0; i < 3; ++i)
+						{
+							uint16_t dim = (uint16_t)msl.get_execution_mode_argument(
+								spv::ExecutionMode::ExecutionModeLocalSize
+								, i
+								);
+							bx::write(_shaderWriter, dim, &err);
+						}
+					}
+
+					const uint32_t shaderSize = (uint32_t)source.size();
+					bx::write(_shaderWriter, shaderSize, &err);
+					bx::write(_shaderWriter, source.c_str(), shaderSize, &err);
+					const uint8_t nul = 0;
+					bx::write(_shaderWriter, nul, &err);
+
+					const uint8_t numAttr = (uint8_t)program->getNumLiveAttributes();
+					bx::write(_shaderWriter, numAttr, &err);
+
+					for (uint8_t ii = 0; ii < numAttr; ++ii)
+					{
+						bgfx::Attrib::Enum attr = toAttribEnum(program->getAttributeName(ii) );
+						if (bgfx::Attrib::Count != attr)
+						{
+							bx::write(_shaderWriter, bgfx::attribToId(attr), &err);
+						}
+						else
+						{
+							bx::write(_shaderWriter, uint16_t(UINT16_MAX), &err);
+						}
+					}
+
+					bx::write(_shaderWriter, size, &err);
+				}
+			}
+		}
+
+		delete program;
+		delete shader;
+
+		glslang::FinalizeProcess();
+
+		return compiled && linked && validated;
+	}
+
+} // namespace metal
+
+	bool compileMetalShader(const Options& _options, uint32_t _version, const std::string& _code, bx::WriterI* _shaderWriter, bx::WriterI* _messageWriter)
+	{
+		return metal::compile(_options, _version, _code, _shaderWriter, _messageWriter, true);
+	}
+
+} // namespace bgfx
diff --git a/brtshaderc/shaderc_pssl.cpp b/brtshaderc/shaderc_pssl.cpp
new file mode 100644
index 0000000..2b23ecb
--- /dev/null
+++ b/brtshaderc/shaderc_pssl.cpp
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2011-2025 Branimir Karadzic. All rights reserved.
+ * License: https://github.com/bkaradzic/bgfx/blob/master/LICENSE
+ */
+
+#include "shaderc.h"
+
+namespace bgfx
+{
+	bool compilePSSLShader(const Options& _options, uint32_t _version, const std::string& _code, bx::WriterI* _shaderWriter, bx::WriterI* _messageWriter)
+	{
+		BX_UNUSED(_options, _version, _code, _shaderWriter);
+		bx::ErrorAssert messageErr;
+		bx::write(_messageWriter, &messageErr, "PSSL compiler is not supported.\n");
+		return false;
+	}
+
+	const char* getPsslPreamble()
+	{
+		return "";
+	}
+
+} // namespace bgfx
diff --git a/brtshaderc/shaderc_spirv.cpp b/brtshaderc/shaderc_spirv.cpp
new file mode 100644
index 0000000..2878cf5
--- /dev/null
+++ b/brtshaderc/shaderc_spirv.cpp
@@ -0,0 +1,906 @@
+/*
+ * Copyright 2011-2025 Branimir Karadzic. All rights reserved.
+ * License: https://github.com/bkaradzic/bgfx/blob/master/LICENSE
+ */
+
+#include "shaderc.h"
+
+#include <iostream> // std::cout
+
+BX_PRAGMA_DIAGNOSTIC_PUSH()
+BX_PRAGMA_DIAGNOSTIC_IGNORED_MSVC(4100) // error C4100: 'inclusionDepth' : unreferenced formal parameter
+BX_PRAGMA_DIAGNOSTIC_IGNORED_MSVC(4265) // error C4265: 'spv::spirvbin_t': class has virtual functions, but destructor is not virtual
+BX_PRAGMA_DIAGNOSTIC_IGNORED_CLANG_GCC("-Wattributes") // warning: attribute ignored
+BX_PRAGMA_DIAGNOSTIC_IGNORED_CLANG_GCC("-Wdeprecated-declarations") // warning: ‘MSLVertexAttr’ is deprecated
+BX_PRAGMA_DIAGNOSTIC_IGNORED_CLANG_GCC("-Wtype-limits") // warning: comparison of unsigned expression in ‘< 0’ is always false
+BX_PRAGMA_DIAGNOSTIC_IGNORED_CLANG_GCC("-Wshadow") // warning: declaration of 'userData' shadows a member of 'glslang::TShader::Includer::IncludeResult'
+#define ENABLE_OPT 1
+#include <ShaderLang.h>
+#include <ResourceLimits.h>
+#include <SPIRV/SPVRemapper.h>
+#include <SPIRV/GlslangToSpv.h>
+#include <SPIRV/SpvTools.h>
+#define SPIRV_CROSS_EXCEPTIONS_TO_ASSERTIONS
+#include <spirv_msl.hpp>
+#include <spirv_reflect.hpp>
+#include <spirv-tools/optimizer.hpp>
+BX_PRAGMA_DIAGNOSTIC_POP()
+
+namespace bgfx
+{
+	struct TinyStlAllocator
+	{
+		static void* static_allocate(size_t _bytes);
+		static void static_deallocate(void* _ptr, size_t /*_bytes*/);
+	};
+} // namespace bgfx
+
+#ifndef BRTSHADERC_LIBRARY
+namespace bgfx
+{
+	static bx::DefaultAllocator s_allocator;
+	bx::AllocatorI* g_allocator = &s_allocator;
+
+	void* TinyStlAllocator::static_allocate(size_t _bytes)
+	{
+		return bx::alloc(g_allocator, _bytes);
+	}
+
+	void TinyStlAllocator::static_deallocate(void* _ptr, size_t /*_bytes*/)
+	{
+		if (NULL != _ptr)
+		{
+			bx::free(g_allocator, _ptr);
+		}
+	}
+} // namespace bgfx
+#endif // BRTSHADERC_LIBRARY
+
+#define TINYSTL_ALLOCATOR bgfx::TinyStlAllocator
+#include <tinystl/allocator.h>
+#include <tinystl/string.h>
+#include <tinystl/unordered_map.h>
+#include <tinystl/vector.h>
+namespace stl = tinystl;
+
+#include "../../src/shader.h"
+#include "../../src/shader_spirv.h"
+#include "../../3rdparty/khronos/vulkan-local/vulkan.h"
+
+namespace bgfx { namespace spirv
+{
+	const TBuiltInResource resourceLimits =
+	{
+		32,    // MaxLights
+		6,     // MaxClipPlanes
+		32,    // MaxTextureUnits
+		32,    // MaxTextureCoords
+		64,    // MaxVertexAttribs
+		4096,  // MaxVertexUniformComponents
+		64,    // MaxVaryingFloats
+		32,    // MaxVertexTextureImageUnits
+		80,    // MaxCombinedTextureImageUnits
+		32,    // MaxTextureImageUnits
+		4096,  // MaxFragmentUniformComponents
+		32,    // MaxDrawBuffers
+		128,   // MaxVertexUniformVectors
+		8,     // MaxVaryingVectors
+		16,    // MaxFragmentUniformVectors
+		16,    // MaxVertexOutputVectors
+		15,    // MaxFragmentInputVectors
+		-8,    // MinProgramTexelOffset
+		7,     // MaxProgramTexelOffset
+		8,     // MaxClipDistances
+		65535, // MaxComputeWorkGroupCountX
+		65535, // MaxComputeWorkGroupCountY
+		65535, // MaxComputeWorkGroupCountZ
+		1024,  // MaxComputeWorkGroupSizeX
+		1024,  // MaxComputeWorkGroupSizeY
+		64,    // MaxComputeWorkGroupSizeZ
+		1024,  // MaxComputeUniformComponents
+		16,    // MaxComputeTextureImageUnits
+		8,     // MaxComputeImageUniforms
+		8,     // MaxComputeAtomicCounters
+		1,     // MaxComputeAtomicCounterBuffers
+		60,    // MaxVaryingComponents
+		64,    // MaxVertexOutputComponents
+		64,    // MaxGeometryInputComponents
+		128,   // MaxGeometryOutputComponents
+		128,   // MaxFragmentInputComponents
+		8,     // MaxImageUnits
+		8,     // MaxCombinedImageUnitsAndFragmentOutputs
+		8,     // MaxCombinedShaderOutputResources
+		0,     // MaxImageSamples
+		0,     // MaxVertexImageUniforms
+		0,     // MaxTessControlImageUniforms
+		0,     // MaxTessEvaluationImageUniforms
+		0,     // MaxGeometryImageUniforms
+		8,     // MaxFragmentImageUniforms
+		8,     // MaxCombinedImageUniforms
+		16,    // MaxGeometryTextureImageUnits
+		256,   // MaxGeometryOutputVertices
+		1024,  // MaxGeometryTotalOutputComponents
+		1024,  // MaxGeometryUniformComponents
+		64,    // MaxGeometryVaryingComponents
+		128,   // MaxTessControlInputComponents
+		128,   // MaxTessControlOutputComponents
+		16,    // MaxTessControlTextureImageUnits
+		1024,  // MaxTessControlUniformComponents
+		4096,  // MaxTessControlTotalOutputComponents
+		128,   // MaxTessEvaluationInputComponents
+		128,   // MaxTessEvaluationOutputComponents
+		16,    // MaxTessEvaluationTextureImageUnits
+		1024,  // MaxTessEvaluationUniformComponents
+		120,   // MaxTessPatchComponents
+		32,    // MaxPatchVertices
+		64,    // MaxTessGenLevel
+		16,    // MaxViewports
+		0,     // MaxVertexAtomicCounters
+		0,     // MaxTessControlAtomicCounters
+		0,     // MaxTessEvaluationAtomicCounters
+		0,     // MaxGeometryAtomicCounters
+		8,     // MaxFragmentAtomicCounters
+		8,     // MaxCombinedAtomicCounters
+		1,     // MaxAtomicCounterBindings
+		0,     // MaxVertexAtomicCounterBuffers
+		0,     // MaxTessControlAtomicCounterBuffers
+		0,     // MaxTessEvaluationAtomicCounterBuffers
+		0,     // MaxGeometryAtomicCounterBuffers
+		1,     // MaxFragmentAtomicCounterBuffers
+		1,     // MaxCombinedAtomicCounterBuffers
+		16384, // MaxAtomicCounterBufferSize
+		4,     // MaxTransformFeedbackBuffers
+		64,    // MaxTransformFeedbackInterleavedComponents
+		8,     // MaxCullDistances
+		8,     // MaxCombinedClipAndCullDistances
+		4,     // MaxSamples
+		0,     // maxMeshOutputVerticesNV
+		0,     // maxMeshOutputPrimitivesNV
+		0,     // maxMeshWorkGroupSizeX_NV
+		0,     // maxMeshWorkGroupSizeY_NV
+		0,     // maxMeshWorkGroupSizeZ_NV
+		0,     // maxTaskWorkGroupSizeX_NV
+		0,     // maxTaskWorkGroupSizeY_NV
+		0,     // maxTaskWorkGroupSizeZ_NV
+		0,     // maxMeshViewCountNV
+		0,     // maxMeshOutputVerticesEXT
+		0,     // maxMeshOutputPrimitivesEXT
+		0,     // maxMeshWorkGroupSizeX_EXT
+		0,     // maxMeshWorkGroupSizeY_EXT
+		0,     // maxMeshWorkGroupSizeZ_EXT
+		0,     // maxTaskWorkGroupSizeX_EXT
+		0,     // maxTaskWorkGroupSizeY_EXT
+		0,     // maxTaskWorkGroupSizeZ_EXT
+		0,     // maxMeshViewCountEXT
+		0,     // maxDualSourceDrawBuffersEXT
+
+		{ // limits
+			true, // nonInductiveForLoops
+			true, // whileLoops
+			true, // doWhileLoops
+			true, // generalUniformIndexing
+			true, // generalAttributeMatrixVectorIndexing
+			true, // generalVaryingIndexing
+			true, // generalSamplerIndexing
+			true, // generalVariableIndexing
+			true, // generalConstantMatrixVectorIndexing
+		},
+	};
+
+	bgfx::TextureComponentType::Enum SpirvCrossBaseTypeToFormatType(spirv_cross::SPIRType::BaseType spirvBaseType, bool depth)
+	{
+		if (depth)
+			return bgfx::TextureComponentType::Depth;
+
+		switch (spirvBaseType)
+		{
+		case spirv_cross::SPIRType::Float:
+			return bgfx::TextureComponentType::Float;
+		case spirv_cross::SPIRType::Int:
+			return bgfx::TextureComponentType::Int;
+		case spirv_cross::SPIRType::UInt:
+			return bgfx::TextureComponentType::Uint;
+		default:
+		    return bgfx::TextureComponentType::Float;
+		}
+	}
+
+	bgfx::TextureDimension::Enum SpirvDimToTextureViewDimension(spv::Dim _dim, bool _arrayed)
+	{
+		switch (_dim)
+		{
+		case spv::Dim::Dim1D:
+			return bgfx::TextureDimension::Dimension1D;
+		case spv::Dim::Dim2D:
+			return _arrayed
+				? bgfx::TextureDimension::Dimension2DArray
+				: bgfx::TextureDimension::Dimension2D
+				;
+		case spv::Dim::Dim3D:
+			return bgfx::TextureDimension::Dimension3D;
+		case spv::Dim::DimCube:
+			return _arrayed
+				? bgfx::TextureDimension::DimensionCubeArray
+				: bgfx::TextureDimension::DimensionCube
+				;
+		default:
+			BX_ASSERT(false, "Unknown texture dimension %d", _dim);
+			return bgfx::TextureDimension::Dimension2D;
+		}
+	}
+
+	static bgfx::TextureFormat::Enum s_textureFormats[] =
+	{
+		bgfx::TextureFormat::Unknown,   // spv::ImageFormatUnknown = 0
+		bgfx::TextureFormat::RGBA32F,   // spv::ImageFormatRgba32f = 1
+		bgfx::TextureFormat::RGBA16F,   // spv::ImageFormatRgba16f = 2
+		bgfx::TextureFormat::R32F,      // spv::ImageFormatR32f = 3
+		bgfx::TextureFormat::RGBA8,     // spv::ImageFormatRgba8 = 4
+		bgfx::TextureFormat::RGBA8S,    // spv::ImageFormatRgba8Snorm = 5
+		bgfx::TextureFormat::RG32F,     // spv::ImageFormatRg32f = 6
+		bgfx::TextureFormat::RG16F,     // spv::ImageFormatRg16f = 7
+		bgfx::TextureFormat::RG11B10F,  // spv::ImageFormatR11fG11fB10f = 8
+		bgfx::TextureFormat::R16F,      // spv::ImageFormatR16f = 9
+		bgfx::TextureFormat::RGBA16,    // spv::ImageFormatRgba16 = 10
+		bgfx::TextureFormat::RGB10A2,   // spv::ImageFormatRgb10A2 = 11
+		bgfx::TextureFormat::RG16,      // spv::ImageFormatRg16 = 12
+		bgfx::TextureFormat::RG8,       // spv::ImageFormatRg8 = 13
+		bgfx::TextureFormat::R16,       // spv::ImageFormatR16 = 14
+		bgfx::TextureFormat::R8,        // spv::ImageFormatR8 = 15
+		bgfx::TextureFormat::RGBA16S,   // spv::ImageFormatRgba16Snorm = 16
+		bgfx::TextureFormat::RG16S,     // spv::ImageFormatRg16Snorm = 17
+		bgfx::TextureFormat::RG8S,      // spv::ImageFormatRg8Snorm = 18
+		bgfx::TextureFormat::R16S,      // spv::ImageFormatR16Snorm = 19
+		bgfx::TextureFormat::R8S,       // spv::ImageFormatR8Snorm = 20
+		bgfx::TextureFormat::RGBA32I,   // spv::ImageFormatRgba32i = 21
+		bgfx::TextureFormat::RGBA16I,   // spv::ImageFormatRgba16i = 22
+		bgfx::TextureFormat::RGBA8I,    // spv::ImageFormatRgba8i = 23
+		bgfx::TextureFormat::R32I,      // spv::ImageFormatR32i = 24
+		bgfx::TextureFormat::RG32I,     // spv::ImageFormatRg32i = 25
+		bgfx::TextureFormat::RG16I,     // spv::ImageFormatRg16i = 26
+		bgfx::TextureFormat::RG8I,      // spv::ImageFormatRg8i = 27
+		bgfx::TextureFormat::R16I,      // spv::ImageFormatR16i = 28
+		bgfx::TextureFormat::R8I,       // spv::ImageFormatR8i = 29
+		bgfx::TextureFormat::RGBA32U,   // spv::ImageFormatRgba32ui = 30
+		bgfx::TextureFormat::RGBA16U,   // spv::ImageFormatRgba16ui = 31
+		bgfx::TextureFormat::RGBA8U,    // spv::ImageFormatRgba8ui = 32
+		bgfx::TextureFormat::R32U,      // spv::ImageFormatR32ui = 33
+		bgfx::TextureFormat::Unknown,   // spv::ImageFormatRgb10a2ui = 34
+		bgfx::TextureFormat::RG32U,     // spv::ImageFormatRg32ui = 35
+		bgfx::TextureFormat::RG16U,     // spv::ImageFormatRg16ui = 36
+		bgfx::TextureFormat::RG8U,      // spv::ImageFormatRg8ui = 37
+		bgfx::TextureFormat::R16U,      // spv::ImageFormatR16ui = 38
+		bgfx::TextureFormat::R8U,       // spv::ImageFormatR8ui = 39
+		bgfx::TextureFormat::Unknown,   // spv::ImageFormatR64ui = 40
+		bgfx::TextureFormat::Unknown,   // spv::ImageFormatR64i = 41
+	};
+
+	static EShLanguage getLang(char _p)
+	{
+		switch (_p)
+		{
+		case 'c': return EShLangCompute;
+		case 'f': return EShLangFragment;
+		case 'v': return EShLangVertex;
+		default:  return EShLangCount;
+		}
+	}
+
+	static const char* s_attribName[] =
+	{
+		"a_position",
+		"a_normal",
+		"a_tangent",
+		"a_bitangent",
+		"a_color0",
+		"a_color1",
+		"a_color2",
+		"a_color3",
+		"a_indices",
+		"a_weight",
+		"a_texcoord0",
+		"a_texcoord1",
+		"a_texcoord2",
+		"a_texcoord3",
+		"a_texcoord4",
+		"a_texcoord5",
+		"a_texcoord6",
+		"a_texcoord7",
+	};
+	static_assert(bgfx::Attrib::Count == BX_COUNTOF(s_attribName) );
+
+	bgfx::Attrib::Enum toAttribEnum(const bx::StringView& _name)
+	{
+		for (uint8_t ii = 0; ii < Attrib::Count; ++ii)
+		{
+			if (0 == bx::strCmp(s_attribName[ii], _name) )
+			{
+				return bgfx::Attrib::Enum(ii);
+			}
+		}
+
+		return bgfx::Attrib::Count;
+	}
+
+	static const char* s_samplerTypes[] =
+	{
+		"BgfxSampler2D",
+		"BgfxISampler2D",
+		"BgfxUSampler2D",
+		"BgfxSampler2DArray",
+		"BgfxSampler2DShadow",
+		"BgfxSampler2DArrayShadow",
+		"BgfxSampler3D",
+		"BgfxISampler3D",
+		"BgfxUSampler3D",
+		"BgfxSamplerCube",
+		"BgfxSamplerCubeShadow",
+		"BgfxSampler2DMS",
+	};
+
+	static uint16_t writeUniformArray(bx::WriterI* _shaderWriter, const UniformArray& uniforms, bool isFragmentShader)
+	{
+		uint16_t size = 0;
+
+		bx::ErrorAssert err;
+
+		uint16_t count = uint16_t(uniforms.size());
+		bx::write(_shaderWriter, count, &err);
+
+		uint32_t fragmentBit = isFragmentShader ? kUniformFragmentBit : 0;
+
+		for (uint16_t ii = 0; ii < count; ++ii)
+		{
+			const Uniform& un = uniforms[ii];
+
+			if ( (un.type & ~kUniformMask) > UniformType::End)
+			{
+				size = bx::max(size, (uint16_t)(un.regIndex + un.regCount*16) );
+			}
+
+			uint8_t nameSize = (uint8_t)un.name.size();
+			bx::write(_shaderWriter, nameSize, &err);
+			bx::write(_shaderWriter, un.name.c_str(), nameSize, &err);
+			bx::write(_shaderWriter, uint8_t(un.type | fragmentBit), &err);
+			bx::write(_shaderWriter, un.num, &err);
+			bx::write(_shaderWriter, un.regIndex, &err);
+			bx::write(_shaderWriter, un.regCount, &err);
+			bx::write(_shaderWriter, un.texComponent, &err);
+			bx::write(_shaderWriter, un.texDimension, &err);
+			bx::write(_shaderWriter, un.texFormat, &err);
+
+			BX_TRACE("%s, %s, %d, %d, %d"
+				, un.name.c_str()
+				, shaderc_getUniformTypeName(UniformType::Enum(un.type & ~kUniformMask))
+				, un.num
+				, un.regIndex
+				, un.regCount
+				);
+		}
+		return size;
+	}
+
+	static spv_target_env getSpirvTargetVersion(uint32_t _version, bx::WriterI* _messageWriter)
+	{
+		bx::ErrorAssert err;
+
+		switch (_version)
+		{
+			case 1010:
+				return SPV_ENV_VULKAN_1_0;
+			case 1311:
+				return SPV_ENV_VULKAN_1_1;
+			case 1411:
+				return SPV_ENV_VULKAN_1_1_SPIRV_1_4;
+			case 1512:
+				return SPV_ENV_VULKAN_1_2;
+			case 1613:
+				return SPV_ENV_VULKAN_1_3;
+			default:
+				bx::write(_messageWriter, &err, "Warning: Unknown SPIR-V version requested. Returning SPV_ENV_VULKAN_1_0 as default.\n");
+				return SPV_ENV_VULKAN_1_0;
+		}
+	}
+
+	static glslang::EShTargetClientVersion getGlslangTargetVulkanVersion(uint32_t _version, bx::WriterI* _messageWriter)
+	{
+		bx::ErrorAssert err;
+
+		switch (_version)
+		{
+			case 1010:
+				return glslang::EShTargetVulkan_1_0;
+			case 1311:
+			case 1411:
+				return glslang::EShTargetVulkan_1_1;
+			case 1512:
+				return glslang::EShTargetVulkan_1_2;
+			case 1613:
+				return glslang::EShTargetVulkan_1_3;
+			default:
+				bx::write(_messageWriter, &err, "Warning: Unknown SPIR-V version requested. Returning EShTargetVulkan_1_0 as default.\n");
+				return glslang::EShTargetVulkan_1_0;
+		}
+	}
+
+	static glslang::EShTargetLanguageVersion getGlslangTargetSpirvVersion(uint32_t _version, bx::WriterI* _messageWriter)
+	{
+		bx::ErrorAssert err;
+
+		switch (_version)
+		{
+			case 1010:
+				return glslang::EShTargetSpv_1_0;
+			case 1311:
+				return glslang::EShTargetSpv_1_3;
+			case 1411:
+				return glslang::EShTargetSpv_1_4;
+			case 1512:
+				return glslang::EShTargetSpv_1_5;
+			case 1613:
+				return glslang::EShTargetSpv_1_6;
+			default:
+				bx::write(_messageWriter, &err, "Warning: Unknown SPIR-V version requested. Returning EShTargetSpv_1_0 as default.\n");
+				return glslang::EShTargetSpv_1_0;
+		}
+	}
+
+	/// This is the value used to fill out GLSLANG's SpvVersion object.
+	/// The required value is that which is defined by GL_KHR_vulkan_glsl, which is defined here:
+	/// https://github.com/KhronosGroup/GLSL/blob/master/extensions/khr/GL_KHR_vulkan_glsl.txt
+	/// The value is 100.
+	constexpr int s_GLSL_VULKAN_CLIENT_VERSION = 100;
+
+	static bool compile(const Options& _options, uint32_t _version, const std::string& _code, bx::WriterI* _shaderWriter, bx::WriterI* _messageWriter, bool _firstPass)
+	{
+		BX_UNUSED(_version);
+
+		bx::ErrorAssert messageErr;
+
+		glslang::InitializeProcess();
+
+		EShLanguage stage = getLang(_options.shaderType);
+		if (EShLangCount == stage)
+		{
+			bx::write(_messageWriter, &messageErr, "Error: Unknown shader type '%c'.\n", _options.shaderType);
+			return false;
+		}
+
+		glslang::TProgram* program = new glslang::TProgram;
+		glslang::TShader* shader   = new glslang::TShader(stage);
+
+		EShMessages messages = EShMessages(0
+			| EShMsgDefault
+			| EShMsgReadHlsl
+			| EShMsgVulkanRules
+			| EShMsgSpvRules
+			| EShMsgDebugInfo
+			);
+
+		shader->setEntryPoint("main");
+		shader->setAutoMapBindings(true);
+		shader->setEnvInput(glslang::EShSourceHlsl, stage, glslang::EShClientVulkan, s_GLSL_VULKAN_CLIENT_VERSION);
+		shader->setEnvClient(glslang::EShClientVulkan, getGlslangTargetVulkanVersion(_version, _messageWriter));
+		shader->setEnvTarget(glslang::EShTargetSpv, getGlslangTargetSpirvVersion(_version, _messageWriter));
+
+		// Reserve two spots for the stage UBOs
+		shader->setShiftBinding(glslang::EResUbo, (stage == EShLanguage::EShLangFragment ? kSpirvFragmentBinding : kSpirvVertexBinding));
+		shader->setShiftBinding(glslang::EResTexture, kSpirvBindShift);
+		shader->setShiftBinding(glslang::EResSampler, kSpirvBindShift + kSpirvSamplerShift);
+		shader->setShiftBinding(glslang::EResSsbo, kSpirvBindShift);
+		shader->setShiftBinding(glslang::EResImage, kSpirvBindShift);
+
+		const char* shaderStrings[] = { _code.c_str() };
+		shader->setStrings(
+			  shaderStrings
+			, BX_COUNTOF(shaderStrings)
+			);
+		bool compiled = shader->parse(&resourceLimits
+			, 110
+			, false
+			, messages
+			);
+		bool linked = false;
+		bool validated = true;
+
+		if (!compiled)
+		{
+			const char* log = shader->getInfoLog();
+			if (NULL != log)
+			{
+				int32_t source  = 0;
+				int32_t line    = 0;
+				int32_t column  = 0;
+				int32_t start   = 0;
+				int32_t end     = INT32_MAX;
+
+				bx::StringView err = bx::strFind(log, "ERROR:");
+
+				bool found = false;
+
+				if (!err.isEmpty() )
+				{
+					found = 2 == sscanf(err.getPtr(), "ERROR: %u:%u: '", &source, &line);
+					if (found)
+					{
+						++line;
+					}
+				}
+
+				if (found)
+				{
+					start = bx::uint32_imax(1, line-10);
+					end   = start + 20;
+				}
+
+				printCode(_code.c_str(), bx::uint32_satsub(line, 1), start, end, column);
+
+				bx::write(_messageWriter, &messageErr, "%s\n", log);
+			}
+		}
+		else
+		{
+			program->addShader(shader);
+			linked = true
+				&& program->link(messages)
+				&& program->mapIO()
+				;
+
+			if (!linked)
+			{
+				const char* log = program->getInfoLog();
+				if (NULL != log)
+				{
+					bx::write(_messageWriter, &messageErr, "%s\n", log);
+				}
+			}
+			else
+			{
+				program->buildReflection();
+
+				if (_firstPass)
+				{
+					// first time through, we just find unused uniforms and get rid of them
+					std::string output;
+
+					struct Uniform
+					{
+						std::string name;
+						std::string decl;
+					};
+					std::vector<Uniform> uniforms;
+
+					bx::LineReader reader(_code.c_str() );
+					while (!reader.isDone() )
+					{
+						bx::StringView strLine = reader.next();
+
+						bool moved = false;
+
+						bx::StringView str = strFind(strLine, "uniform ");
+						if (!str.isEmpty() )
+						{
+							bool found = false;
+							bool sampler = false;
+							std::string name = "";
+
+							// add to samplers
+
+							for (uint32_t ii = 0; ii < BX_COUNTOF(s_samplerTypes); ++ii)
+							{
+								if (!bx::findIdentifierMatch(strLine, s_samplerTypes[ii]).isEmpty() )
+								{
+									found = true;
+									sampler = true;
+									break;
+								}
+							}
+
+							if (!found)
+							{
+								for (int32_t ii = 0, num = program->getNumLiveUniformVariables(); ii < num; ++ii)
+								{
+									// matching lines like:  uniform u_name;
+									// we want to replace "uniform" with "static" so that it's no longer
+									// included in the uniform blob that the application must upload
+									// we can't just remove them, because unused functions might still reference
+									// them and cause a compile error when they're gone
+									if (!bx::findIdentifierMatch(strLine, program->getUniformName(ii) ).isEmpty() )
+									{
+										found = true;
+										name = program->getUniformName(ii);
+										break;
+									}
+								}
+							}
+
+							if (!found)
+							{
+								output.append(strLine.getPtr(), str.getPtr() );
+								output += "static ";
+								output.append(str.getTerm(), strLine.getTerm() );
+								output += "\n";
+								moved = true;
+							}
+							else if (!sampler)
+							{
+								Uniform uniform;
+								uniform.name = name;
+								uniform.decl = std::string(strLine.getPtr(), strLine.getTerm() );
+								uniforms.push_back(uniform);
+								moved = true;
+							}
+						}
+
+						if (!moved)
+						{
+							output.append(strLine.getPtr(), strLine.getTerm() );
+							output += "\n";
+						}
+					}
+
+					std::string uniformBlock;
+					uniformBlock += "cbuffer UniformBlock\n";
+					uniformBlock += "{\n";
+
+					for (const Uniform& uniform : uniforms)
+					{
+						uniformBlock += uniform.decl.substr(7 /* uniform */);
+						uniformBlock += "\n";
+					}
+
+					uniformBlock += "};\n";
+
+					output = uniformBlock + output;
+
+					// recompile with the unused uniforms converted to statics
+					delete program;
+					delete shader;
+					return compile(_options, _version, output.c_str(), _shaderWriter, _messageWriter, false);
+				}
+
+				UniformArray uniforms;
+
+				{
+					uint16_t count = (uint16_t)program->getNumLiveUniformVariables();
+
+					for (uint16_t ii = 0; ii < count; ++ii)
+					{
+						Uniform un;
+						un.name = program->getUniformName(ii);
+
+						if (bx::hasSuffix(un.name.c_str(), ".@data") )
+						{
+							continue;
+						}
+
+						un.num = uint8_t(program->getUniformArraySize(ii) );
+						const uint32_t offset = program->getUniformBufferOffset(ii);
+						un.regIndex = uint16_t(offset);
+						un.regCount = un.num;
+
+						switch (program->getUniformType(ii) )
+						{
+						case 0x1404: // GL_INT:
+							un.type = UniformType::Sampler;
+							break;
+
+						case 0x8B52: // GL_FLOAT_VEC4:
+							un.type = UniformType::Vec4;
+							break;
+
+						case 0x8B5B: // GL_FLOAT_MAT3:
+							un.type = UniformType::Mat3;
+							un.regCount *= 3;
+							break;
+
+						case 0x8B5C: // GL_FLOAT_MAT4:
+							un.type = UniformType::Mat4;
+							un.regCount *= 4;
+							break;
+
+						default:
+							continue;
+						}
+
+						uniforms.push_back(un);
+					}
+				}
+
+				if (g_verbose)
+				{
+					program->dumpReflection();
+				}
+
+				glslang::TIntermediate* intermediate = program->getIntermediate(stage);
+				std::vector<uint32_t> spirv;
+
+				glslang::SpvOptions options;
+				options.disableOptimizer = _options.debugInformation;
+				options.generateDebugInfo = _options.debugInformation;
+				options.emitNonSemanticShaderDebugInfo = _options.debugInformation;
+				options.emitNonSemanticShaderDebugSource = _options.debugInformation;
+
+				glslang::GlslangToSpv(*intermediate, spirv, &options);
+
+				spvtools::Optimizer opt(getSpirvTargetVersion(_version, _messageWriter));
+
+				auto print_msg_to_stderr = [_messageWriter, &messageErr](
+					  spv_message_level_t
+					, const char*
+					, const spv_position_t&
+					, const char* m
+					)
+				{
+					bx::write(_messageWriter, &messageErr, "Error: %s\n", m);
+				};
+
+				opt.SetMessageConsumer(print_msg_to_stderr);
+
+				opt.RegisterLegalizationPasses();
+
+				spvtools::ValidatorOptions validatorOptions;
+				validatorOptions.SetBeforeHlslLegalization(true);
+
+				if (!opt.Run(
+					  spirv.data()
+					, spirv.size()
+					, &spirv
+					, validatorOptions
+					, false
+					) )
+				{
+					compiled = false;
+				}
+				else
+				{
+					if (g_verbose)
+					{
+						glslang::SpirvToolsDisassemble(std::cout, spirv, getSpirvTargetVersion(_version, _messageWriter));
+					}
+
+					spirv_cross::CompilerReflection refl(spirv);
+					spirv_cross::ShaderResources resourcesrefl = refl.get_shader_resources();
+
+					// Loop through the separate_images, and extract the uniform names:
+					for (auto &resource : resourcesrefl.separate_images)
+					{
+						std::string name = refl.get_name(resource.id);
+
+						if (name.size() > 7
+						&&  0 == bx::strCmp(name.c_str() + name.length() - 7, "Texture") )
+						{
+							name = name.substr(0, name.length() - 7);
+						}
+
+						uint32_t binding_index = refl.get_decoration(resource.id, spv::Decoration::DecorationBinding);
+
+						auto imageType = refl.get_type(resource.base_type_id).image;
+						auto componentType = refl.get_type(imageType.type).basetype;
+
+						bool isCompareSampler = false;
+						for (auto& sampler : resourcesrefl.separate_samplers)
+						{
+							if (binding_index + 16 == refl.get_decoration(sampler.id, spv::Decoration::DecorationBinding) )
+							{
+								std::string samplerName = refl.get_name(sampler.id);
+								isCompareSampler = refl.variable_is_depth_or_compare(sampler.id) || samplerName.find("Comparison") != std::string::npos;
+								break;
+							}
+						}
+
+						Uniform un;
+						un.name = name;
+						un.type = UniformType::Enum(UniformType::Sampler
+								| kUniformSamplerBit
+								| (isCompareSampler ? kUniformCompareBit : 0)
+								);
+
+						un.texComponent = textureComponentTypeToId(SpirvCrossBaseTypeToFormatType(componentType, imageType.depth) );
+						un.texDimension = textureDimensionToId(SpirvDimToTextureViewDimension(imageType.dim, imageType.arrayed) );
+						un.texFormat = uint16_t(s_textureFormats[imageType.format]);
+
+						un.regIndex = uint16_t(binding_index);
+						un.regCount = 0; // unused
+
+						uniforms.push_back(un);
+					}
+
+					// Loop through the storage_images, and extract the uniform names:
+					for (auto &resource : resourcesrefl.storage_images)
+					{
+						std::string name = refl.get_name(resource.id);
+
+						uint32_t binding_index = refl.get_decoration(resource.id, spv::Decoration::DecorationBinding);
+
+						auto imageType = refl.get_type(resource.base_type_id).image;
+						auto componentType = refl.get_type(imageType.type).basetype;
+
+						spirv_cross::Bitset flags = refl.get_decoration_bitset(resource.id);
+						UniformType::Enum type = flags.get(spv::DecorationNonWritable)
+							? UniformType::Enum(kUniformReadOnlyBit | UniformType::End)
+							: UniformType::End;
+
+						Uniform un;
+						un.name = name;
+						un.type = type;
+
+						un.texComponent = textureComponentTypeToId(SpirvCrossBaseTypeToFormatType(componentType, imageType.depth) );
+						un.texDimension = textureDimensionToId(SpirvDimToTextureViewDimension(imageType.dim, imageType.arrayed) );
+						un.texFormat = uint16_t(s_textureFormats[imageType.format]);
+
+						un.regIndex = uint16_t(binding_index);
+						un.regCount = descriptorTypeToId(DescriptorType::StorageImage);
+
+						uniforms.push_back(un);
+					}
+
+					bx::Error err;
+
+					// Loop through the storage buffer, and extract the uniform names:
+					for (auto& resource : resourcesrefl.storage_buffers)
+					{
+						std::string name = refl.get_name(resource.id);
+
+						uint32_t binding_index = refl.get_decoration(resource.id, spv::Decoration::DecorationBinding);
+
+						spirv_cross::Bitset flags = refl.get_buffer_block_flags(resource.id);
+						UniformType::Enum type = flags.get(spv::DecorationNonWritable)
+							? UniformType::Enum(kUniformReadOnlyBit | UniformType::End)
+							: UniformType::End;
+
+						Uniform un;
+						un.name = name;
+						un.type = type;
+						un.num = 0;
+						un.regIndex = uint16_t(binding_index);
+						un.regCount = descriptorTypeToId(DescriptorType::StorageBuffer);
+
+						uniforms.push_back(un);
+					}
+
+					uint16_t size = writeUniformArray(_shaderWriter, uniforms, _options.shaderType == 'f');
+
+					uint32_t shaderSize = (uint32_t)spirv.size() * sizeof(uint32_t);
+					bx::write(_shaderWriter, shaderSize, &err);
+					bx::write(_shaderWriter, spirv.data(), shaderSize, &err);
+					uint8_t nul = 0;
+					bx::write(_shaderWriter, nul, &err);
+
+					const uint8_t numAttr = (uint8_t)program->getNumLiveAttributes();
+					bx::write(_shaderWriter, numAttr, &err);
+
+					for (uint8_t ii = 0; ii < numAttr; ++ii)
+					{
+						bgfx::Attrib::Enum attr = toAttribEnum(program->getAttributeName(ii) );
+						if (bgfx::Attrib::Count != attr)
+						{
+							bx::write(_shaderWriter, bgfx::attribToId(attr), &err);
+						}
+						else
+						{
+							bx::write(_shaderWriter, uint16_t(UINT16_MAX), &err);
+						}
+					}
+
+					bx::write(_shaderWriter, size, &err);
+				}
+			}
+		}
+
+		delete program;
+		delete shader;
+
+		glslang::FinalizeProcess();
+
+		return compiled && linked && validated;
+	}
+
+} // namespace spirv
+
+	bool compileSPIRVShader(const Options& _options, uint32_t _version, const std::string& _code, bx::WriterI* _shaderWriter, bx::WriterI* _messageWriter)
+	{
+		return spirv::compile(_options, _version, _code, _shaderWriter, _messageWriter, true);
+	}
+
+} // namespace bgfx
diff --git a/cmake/bgfx/CMakeLists.txt b/cmake/bgfx/CMakeLists.txt
index 0125da3..3abc951 100644
--- a/cmake/bgfx/CMakeLists.txt
+++ b/cmake/bgfx/CMakeLists.txt
@@ -27,6 +27,7 @@ if(BGFX_BUILD_TOOLS_SHADER)
 	include(3rdparty/fcpp.cmake)
 	include(3rdparty/webgpu.cmake)
 	include(shaderc.cmake)
+	include(brtshaderc.cmake)
 endif()
 
 include(shared.cmake)
diff --git a/cmake/bgfx/brtshaderc.cmake b/cmake/bgfx/brtshaderc.cmake
new file mode 100644
index 0000000..dc69ca9
--- /dev/null
+++ b/cmake/bgfx/brtshaderc.cmake
@@ -0,0 +1,55 @@
+# bgfx.cmake - bgfx building in cmake
+# Written in 2017 by Joshua Brookover <joshua.al.brookover@gmail.com>
+#
+# To the extent possible under law, the author(s) have dedicated all copyright
+# and related and neighboring rights to this software to the public domain
+# worldwide. This software is distributed without any warranty.
+#
+# You should have received a copy of the CC0 Public Domain Dedication along with
+# this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
+
+# Grab the brtshaderc source files
+file(
+	GLOB
+	BRTSHADERC_SOURCES #
+	${BGFX_DIR}/src/shader* #
+    ${BRTSHADERC_DIR}/*.cpp #
+    ${BRTSHADERC_DIR}/*.h #
+)
+
+add_library(brtshaderc STATIC ${BRTSHADERC_SOURCES})
+
+target_include_directories(brtshaderc PUBLIC ${BRTSHADERC_DIR})
+
+add_compile_definitions(BRTSHADERC_LIBRARY)
+
+target_link_libraries(
+	brtshaderc
+	PRIVATE bx
+			bgfx-vertexlayout
+			fcpp
+			glslang
+			glsl-optimizer
+			spirv-opt
+			spirv-cross
+)
+target_link_libraries(
+	brtshaderc
+	PRIVATE bx
+			bimg
+			bgfx-vertexlayout
+			fcpp
+			glslang
+			glsl-optimizer
+			spirv-opt
+			spirv-cross
+			webgpu
+)
+if(BGFX_AMALGAMATED)
+	target_link_libraries(brtshaderc PRIVATE bgfx-shader)
+endif()
+
+set_target_properties(
+	brtshaderc PROPERTIES FOLDER "bgfx/tools" #
+					   OUTPUT_NAME ${BGFX_TOOLS_PREFIX}brtshaderc #
+)
